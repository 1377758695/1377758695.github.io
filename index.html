<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"weihongpan.github.io","root":"/","scheme":"Gemini","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":"mac","style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":true},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="跬步千里">
<meta property="og:type" content="website">
<meta property="og:title" content="潘薇鸿">
<meta property="og:url" content="https://weihongpan.github.io/index.html">
<meta property="og:site_name" content="潘薇鸿">
<meta property="og:description" content="跬步千里">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="潘薇鸿">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://weihongpan.github.io/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>潘薇鸿</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">潘薇鸿</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">keep on fighting</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>

  <a href="https://github.com/WeihongPan" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%BA%8C%E8%AE%B2-%CE%BB%E7%9F%A9%E9%98%B5%E4%B8%8EJordan%E6%A0%87%E5%87%86%E5%9E%8B/" class="post-title-link" itemprop="url">矩阵分析学习笔记2：多项式矩阵与Jordan标准型</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-28 13:30:03" itemprop="dateCreated datePublished" datetime="2021-05-28T13:30:03+08:00">2021-05-28</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 08:47:15" itemprop="dateModified" datetime="2021-05-29T08:47:15+08:00">2021-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h3 id="Chapter2-lambda-矩阵与Jordan标准型"><a href="#Chapter2-lambda-矩阵与Jordan标准型" class="headerlink" title="Chapter2 $\lambda$ 矩阵与Jordan标准型"></a>Chapter2 $\lambda$ 矩阵与Jordan标准型</h3><p>为了解决数域矩阵相似最简型的问题，我们引入 $\lambda$ 矩阵</p>
<h4 id="lambda-矩阵及其Smith型"><a href="#lambda-矩阵及其Smith型" class="headerlink" title="$\lambda$ 矩阵及其Smith型"></a>$\lambda$ 矩阵及其Smith型</h4><h5 id="lambda-矩阵"><a href="#lambda-矩阵" class="headerlink" title="$\lambda$ 矩阵"></a>$\lambda$ 矩阵</h5><p>以多项式为元素的矩阵</p>
<ul>
<li>$\mathbb{F}[\lambda]$ ：表示以数域 $\mathbb{F}$ 中的元素为系数的多项式集合</li>
<li>$(\mathbb{F}[\lambda])^{m\times n}=\{[a_{ij}(\lambda)]_{m\times n}|a_{ij}(\lambda)\in \mathbb{F}[\lambda]\}$ （类比 $\mathbb{F}^{m\times n}$） </li>
<li>$\lambda$ 矩阵： $\boldsymbol{A}(\lambda)=[a_{ij}(\lambda)]_{m\times n},\ a_{ij}(\lambda)\in\mathbb{F}[\lambda],\ \boldsymbol{A}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$  </li>
<li>从映射观点看 $\lambda$ 矩阵：$\mathbb{F}\rightarrow\mathbb{F}^{m\times n},\ \lambda\mapsto\boldsymbol{A}(\lambda)$ </li>
<li>从矩阵多项式观点看 $\lambda$ 矩阵：$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+$ ，即以矩阵为系数的多项式</li>
</ul>
<p>$\lambda$ 矩阵的秩</p>
<ul>
<li>不为<strong>零多项式</strong>的子式的最大阶数 （以多项式为元素算行列式）</li>
</ul>
<h5 id="单位模阵（幺模阵）"><a href="#单位模阵（幺模阵）" class="headerlink" title="单位模阵（幺模阵）"></a>单位模阵（幺模阵）</h5><ul>
<li>对 $\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ ，若 $\exists\ \boldsymbol{V}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n},\ s.t.\ \boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{V}(\lambda)\boldsymbol{U}(\lambda)=\boldsymbol{I}_n$ ，则称 $\boldsymbol{V}(\lambda)$ 为 $\boldsymbol{U}(\lambda)$ 的单位模阵。</li>
</ul>
<p>单位模阵：逆矩阵，且必须是多项式矩阵，因为单纯逆矩阵 $\boldsymbol{A}^{-1}=\frac{1}{|\boldsymbol{A}|}\boldsymbol{A}^*$ 不一定是多项式矩阵</p>
<p>多项式矩阵相对于前面所谈论的数值矩阵，主要不同就在于除法运算上，即多项式相除结果不一定还是多项式。用抽象数学的概念，数值矩阵谈论是<strong>域</strong>上的矩阵，而多项式矩阵谈论的是<strong>环</strong>上的矩阵</p>
<ul>
<li>$\boldsymbol{U}(\lambda)\in(\mathbb{F}[\lambda])^{n\times n}$ 为单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|$ 是非零常值多项式（即 $a_0\neq 0$ 的零次多项式）</li>
</ul>
<p>下面给出证明：</p>
<p>$\Leftarrow$ ：显然</p>
<p>$\Rightarrow$ ：存在多项式矩阵 $\boldsymbol{V}(\lambda)$ ，使得 $\boldsymbol{U}(\lambda)\boldsymbol{V}(\lambda)=\boldsymbol{I}_n\Rightarrow|\boldsymbol{U}(\lambda)||\boldsymbol{V}(\lambda)|=1\Rightarrow f(\lambda)g(\lambda)=1$ ，两个多项式相乘等于1，这两个多项式只能是 $a_0\neq 0$ 的零次多项式，否则相乘一定有变量在 </p>
<h5 id="lambda-矩阵的初等行（列）变换"><a href="#lambda-矩阵的初等行（列）变换" class="headerlink" title="$\lambda$ 矩阵的初等行（列）变换"></a>$\lambda$ 矩阵的初等行（列）变换</h5><p>以初等行变换为例 $\Leftrightarrow$ 左乘一个相应的初等矩阵：</p>
<ul>
<li><p>某两行互换 $\Leftrightarrow$ eg. $\begin{bmatrix} 0&amp;1&amp;0\\1&amp;0&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
<li><p><strong>某行乘以非零常数</strong> $\Leftrightarrow$ eg. $\begin{bmatrix} c&amp;0&amp;0\\0&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
<p>注：不是乘以非零多项式！因为乘以多项式是不可逆的，即对应乘上的矩阵没有单位模阵</p>
</li>
<li><p>某行乘以一个多项式再加到另一行上 $\Leftrightarrow$ eg. $\begin{bmatrix}1&amp;0&amp;0\\f(\lambda)&amp;1&amp;0\\0&amp;0&amp;1\end{bmatrix}$ </p>
</li>
</ul>
<h5 id="lambda-矩阵经左右初等变换化简"><a href="#lambda-矩阵经左右初等变换化简" class="headerlink" title="$\lambda$ 矩阵经左右初等变换化简"></a>$\lambda$ 矩阵经左右初等变换化简</h5><ul>
<li><p>$\lambda$ 矩阵的等价：经初等行列变换可以互相转化的两个 $\lambda$ 矩阵等价，记作 $\boldsymbol{A}(\lambda) \sim \boldsymbol{B}(\lambda) $ </p>
</li>
<li><p>【用初等行变换为矩阵左上角降次】设 $\boldsymbol{A}(\lambda) =[a_{ij}(\lambda)]_{m\times n},\ a_{11}(\lambda)\neq0$ ， 且至少有一个元素不能被 $a_{11}(\lambda)$ 整除（$\Leftrightarrow a_{11}(\lambda)$ 不为非零常值多项式 ），则有 $\boldsymbol{A}(\lambda) \sim\boldsymbol{B}(\lambda) $ 且 $b_{11}(\lambda)\neq0,\ \partial(b_{11}(\lambda))&lt;\partial(a_{11}(\lambda))$ （$\partial(多项式)$ 表示该多项式的次数）</p>
<p>下面给出证明概要：</p>
<ul>
<li><p>同行中有一个元素 $a_{1j}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，即 $a_{1j}(\lambda)=a_{11}(\lambda)q(\lambda)+r(\lambda),\ 且\ \partial(r(\lambda))&lt;\partial(a(\lambda))$ ，所以，将第一列乘以 $-q(\lambda)$ 加到第 $j$ 列后交换第一列与第 $j$ 列，此时 $a_{11}(\lambda)’=r(\lambda),\partial(a_{11}(\lambda)’)&lt;\partial(a_{11}(\lambda))$ ，从而实现降次</p>
</li>
<li><p>同列中有一个元素 $a_{i1}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除，同理</p>
</li>
<li><p>同行同列都能被整除，但有 $a_{ij}(\lambda)$ 不能被 $a_{11}(\lambda)$ 整除。</p>
<p>首先可以通过一系列行列变换把第一列、第一行除了 $a_{11}(\lambda)$ 外都化为0，同时保证变换后的 $a_{ij}(\lambda)’$ 仍旧不能被 $a_{11}(\lambda)$ 整除（不能被整除的数加上除数的倍数依然不能被整除），将变换后的第 $j$ 行加到第1行，就回到第一种情况了</p>
</li>
</ul>
</li>
</ul>
<h5 id="Smith-型-lambda-矩阵"><a href="#Smith-型-lambda-矩阵" class="headerlink" title="Smith 型 $\lambda$ 矩阵"></a>Smith 型 $\lambda$ 矩阵</h5><p>设：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}(\lambda)\sim \boldsymbol{B}(\lambda)=
\left[
\begin{array}{ccc|ccc}
    d_1({\lambda}) & & & 0 & \cdots & 0\\
    & \ddots & &\vdots &\ddots &\vdots \\
    & & d_r(\lambda) &0 &\cdots &0 \\
    \hline 
    0 & \cdots & 0 &0 &\cdots &0 \\
    \vdots &\ddots &\vdots &\vdots &\ddots &\vdots \\
    0 & \cdots & 0 &0 &\cdots &0
\end{array}
\right]</script><p>其中 $r=\text{rank}(\boldsymbol{A}(\lambda))$ ，$d_i(\lambda)$ 为非零多项式，且 $d_i(\lambda)|d_{i+1}(\lambda)$ （$f(\lambda)|g(\lambda)$ 表示 $f$ 整除 $g$ ），则称 $\boldsymbol{B}(\lambda)$ 为 $\boldsymbol{A}(\lambda)$ 的 <code>Smith标准型</code> 。</p>
<p>下面给出证明：</p>
<ul>
<li><p>存在性</p>
<p>若为零矩阵，则显然；若为非零矩阵，必存在非零多项式，通过行列变换将次数最低的非零多项式移到 $a_{11}(\lambda)$ ，会出现以下两种情况：</p>
<ul>
<li>矩阵中所有元素都能被 $a_{11}(\lambda)$ 整除</li>
<li>存在若干元素不能被 $a_{11}(\lambda)$ 整除</li>
</ul>
<p>对于第二种情况，【用初等行变换为左上角降次】，降次必然是有限的，不能再降次的时候，也就是矩阵中的所有元素都能被 $a_{11}(\lambda)$ 整除的时候 ，进而同行同列的元素都能化成0</p>
<p>对右下子矩阵进行相同的操作，以此类推，最终得到 <code>Smith标准型</code> </p>
</li>
<li><p>唯一性</p>
<p>约定 $d_i(\lambda)$ 都是首1多项式，即最高次数系数为1</p>
<ul>
<li><p><strong>$\lambda$ 矩阵的 $k$ 阶行列式因子</strong> ：$\boldsymbol{A}(\lambda)$ 的所有 $k$ 阶子式的最高公因式</p>
</li>
<li><p><strong>初等变换不改变 $k$ 阶行列式因子</strong> </p>
<p>下面给出证明：</p>
<p>设 $\mathscr{A}=\{\boldsymbol{A}\ 的\ k\ 阶子式\},\mathscr{B}=\{\boldsymbol{B}\ 的\ k\ 阶子式\}$ ，只需证 $\mathscr{A},\mathscr{B}$ 的最高公因式相同。</p>
<p>任取 $f(\lambda)\in\mathscr{B}$ ，考察它与 $\mathscr{A}$ 中多项式的关系，由于初等变换是三种基本变换的组合，所以只需分别对三种基本变换进行讨论即可：</p>
<ol>
<li><p>某两行互换：只影响行列式的符号，因为约定了所有多项式都是首1多项式，所以这种变换对子式集合无影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个非零常数：同样，因为约定了所有多项式都是首1多项式，所以也不会有影响，即 $\mathscr{A}=\mathscr{B}$ ，那么必有 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>某行乘以一个多项式再加到另一行上。假设是第 $i$ 行乘以 $h(\lambda)$ 加到第 $j$ 行。那么：</p>
<ul>
<li><p>如果 $f(\lambda)$ 没有取到第 $j$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ ；</p>
</li>
<li><p>如果 $f(\lambda)$ 取到了第 $j$ 行：</p>
<ul>
<li><p>如果同时取到了第 $i$ 行，那么该子式不发生变化，即 $f(\lambda)\in\mathscr{A}$ </p>
</li>
<li><p>如果没有取到第 $i$ 行，显然  $f(\lambda)\notin\mathscr{A}$  ，但是可以将它对应的行列式拆分：</p>
<script type="math/tex; mode=display">
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j+\boldsymbol{a_i}\cdot h(\lambda) \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right| = 
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a}_j \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|+
\left|
\begin{array}{c}
    \boldsymbol{a}_p \\
    \vdots \\
    \boldsymbol{a_i} \\
    \vdots \\
    \boldsymbol{a}_{p+k-1}
\end{array}
\right|\cdot h(\lambda)</script><p>即：$f(\lambda)=g(\lambda)+w(\lambda)\cdot h(\lambda)$，其中 $g(\lambda),w(\lambda)\in\mathscr{A}$ ，所以 $\mathscr{A}$ 的公因式必整除 $f(\lambda)$ </p>
</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>综上，$\mathscr{A}$ 的公因式必能整除 $\mathscr{B}$ 中的所有子式，由于初等变换可逆知，$\mathscr{B}$ 的公因式也必能整除 $\mathscr{A}$ 中的所有子式，从而二者的最高公因式相同</p>
</li>
<li><p><strong>不变因子 $d_{i}(\lambda)$</strong>  </p>
<p>记 $k$ 阶行列式因子为 $D_k(\lambda)$ ，初等变换不改变行列式因子，所以：</p>
<script type="math/tex; mode=display">
d_1(\lambda) = D_1(\lambda),\ d_i(\lambda)=D_i(\lambda)/D_{i-1}(\lambda)</script><p>因此，称 $d_i(\lambda)$ 为不变因子（行列式因子唯一，所以 $d_i(\lambda)$ 一定唯一）</p>
</li>
</ul>
</li>
</ul>
<h5 id="两种方法求Smith型"><a href="#两种方法求Smith型" class="headerlink" title="两种方法求Smith型"></a>两种方法求Smith型</h5><ul>
<li><p>初等变换：找次数最低项，要么能整除，要么能降次（带余除法）</p>
<p>例：</p>
<script type="math/tex; mode=display">
\begin{align}
\begin{bmatrix}\lambda(\lambda+1)&0&0\\0&\lambda&0\\0&0&(\lambda+1)^2\end{bmatrix} 

&\xrightarrow[]{最低次放左上角}
&\begin{bmatrix}\lambda&0&0\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[加到第一行]{不能整除的某行}
&\begin{bmatrix}\lambda&0&(\lambda+1)^2\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{带余除法降次}
&\begin{bmatrix}\lambda&0&1\\0&\lambda(\lambda+1)&0\\0&0&(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[重复带余除法直到能整除]{最低次换到左上角}
&\begin{bmatrix}1&0&\lambda\\0&\lambda(\lambda+1)&0\\(\lambda+1)^2&0&0\end{bmatrix} \notag \\

&\xrightarrow[]{同行同列化零}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&-\lambda(\lambda+1)^2\end{bmatrix} \notag \\

&\xrightarrow[]{化为首1多项式}
&\begin{bmatrix}1&0&0\\ 0&\lambda(\lambda+1)&0\\ 0&0&\lambda(\lambda+1)^2\end{bmatrix} \notag \\
\end{align}</script></li>
<li><p>计算所有行列式因子</p>
<p>同上例，有 $D_1(\lambda)=1,D_2(\lambda)=\lambda(\lambda+1),D_3=\lambda^2(\lambda+1)^3$ ，故而 $d_1(\lambda)=1, d_2(\lambda)=\lambda(\lambda+1),d_3(\lambda)=\lambda(\lambda+1)^2$ </p>
</li>
</ul>
<h5 id="单位模阵可写成初等矩阵乘积"><a href="#单位模阵可写成初等矩阵乘积" class="headerlink" title="单位模阵可写成初等矩阵乘积"></a>单位模阵可写成初等矩阵乘积</h5><ul>
<li><p>单位模阵的 Smith 型为单位矩阵</p>
<p>下面给出证明：</p>
<p>$\boldsymbol{U}(\lambda)$ 是单位模阵 $\Leftrightarrow |\boldsymbol{U}(\lambda)|=c\neq0$ （为非零常数）$\Leftrightarrow\boldsymbol{U}(\lambda)$ 的 $n$ 阶行列式因子为1，且 $r=\text{rank}(\boldsymbol{U})=n$ </p>
<p>又：$D_n(\lambda)=D_1(\lambda)\frac{D_2(\lambda)}{D_1(\lambda)}\cdots\frac{D_n(\lambda)}{D_{n-1}(\lambda)}=d_1(\lambda)d_2(\lambda)\cdots d_n(\lambda)$  </p>
<p>所以：$d_i(\lambda)=1$ ，证毕</p>
</li>
</ul>
<p>据此，单位模阵经过若干次初等变换后可以变成单位矩阵，写成矩阵的形式即为：</p>
<script type="math/tex; mode=display">
\boldsymbol{P}_s(\lambda)\cdots\boldsymbol{P}_1(\lambda)\boldsymbol{U}(\lambda)\boldsymbol{Q}_1(\lambda)\cdots\boldsymbol{Q}_t(\lambda)=\boldsymbol{I}</script><p>初等矩阵的逆矩阵仍为初等矩阵，因此：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=\boldsymbol{P}_1^{-1}(\lambda)\cdots\boldsymbol{P}_s^{-1}(\lambda)\boldsymbol{Q}_t^{-1}(\lambda)\boldsymbol{Q}_1^{-1}(\lambda)</script><h4 id="数域矩阵相似最简型问题"><a href="#数域矩阵相似最简型问题" class="headerlink" title="数域矩阵相似最简型问题"></a>数域矩阵相似最简型问题</h4><ul>
<li>特征矩阵：给定 $\boldsymbol{A}\in\mathbb{F}^{n\times n}$ ，称多项式矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 为矩阵 $\boldsymbol{A}$ 的特征矩阵</li>
</ul>
<h5 id="数域矩阵相似-Leftrightarrow-特征矩阵等价"><a href="#数域矩阵相似-Leftrightarrow-特征矩阵等价" class="headerlink" title="数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价"></a>数域矩阵相似 $\Leftrightarrow$ 特征矩阵等价</h5><p>把一个受约束的相似问题【 $\boldsymbol{AP}=\boldsymbol{PB}$ 行列变换必须配套】转换成了一个不受约束的等价问题【 $\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B}$ 行列变换无需配套】 </p>
<p>下面给出证明：</p>
<ul>
<li><p>多项式矩阵的<strong>次数</strong></p>
<p>若 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+A_2\lambda^2+\cdots+A_r\lambda^r,\ 且\ A_r\neq0$ ，则称 $\boldsymbol{A}(\lambda)$ 的次数为 $r$ ，记作 $\partial(\boldsymbol{A}(\lambda))=r$ 。特别地，零多项式矩阵的次数无意义。</p>
</li>
<li><p>多项式矩阵<strong>乘积的次数</strong> </p>
<p> $\boldsymbol{A}(\lambda)\boldsymbol{B}(\lambda)=\boldsymbol{C}(\lambda)$，且 $\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r$ ，若满足：</p>
<p>​    1）三个矩阵均非零（零矩阵的次数无意义） </p>
<p>​    2）$A_r\in \mathbb{F}^{m\times m}$ 可逆（保证 $\boldsymbol{C}(\lambda)$ 的最高次矩阵系数 $C_{r+s}(\lambda)=A_r(\lambda)B_s(\lambda)$ 非零）</p>
<p>那么 $\partial(\boldsymbol{C}(\lambda))=\partial(\boldsymbol{A}(\lambda))+\partial(\boldsymbol{B}(\lambda))$ </p>
</li>
<li><p>多项式矩阵的带余除法（以左除为例）：</p>
<p>$\boldsymbol{A}(\lambda) = A_0+A_1\lambda+\cdots+A_r\lambda^r\in(\mathbb{F}[\lambda])^{m\times m}$ ，若满足 $A_r\in\mathbb{F}^{m\times m}$ <strong>可逆</strong>，那么对非零矩阵 $\boldsymbol{B}(\lambda)\in(\mathbb{F}[\lambda])^{m\times n}$ ，存在<strong>唯一</strong>矩阵 $\boldsymbol{Q}(\lambda), \boldsymbol{R}(\lambda)$ ，使得：$\boldsymbol{B}(\lambda)=\boldsymbol{A}(\lambda)\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)$ ，其中 $\boldsymbol{R}(\lambda)=\boldsymbol{0}$ 或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\boldsymbol{A}(\lambda))$  </p>
</li>
</ul>
<p>$\Rightarrow$ ：取 $\boldsymbol{U}(\lambda)=\boldsymbol{P}^{-1},\boldsymbol{V}(\lambda)=\boldsymbol{P}$ ，因为 $\boldsymbol{P}$ 可逆，故行列式为非零常数，满足单位模阵的要求</p>
<p>$\Leftarrow$ ：从 $\boldsymbol{U},\boldsymbol{V}$ 找 $\boldsymbol{P}$ </p>
<p>根据多项式矩阵带余除法，因为 $\boldsymbol{I}$ 可逆，所以：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}(\lambda)</script><p>其中：$\boldsymbol{R}(\lambda)=\boldsymbol{0}$ ，或 $\partial(\boldsymbol{R}(\lambda))&lt;\partial(\lambda\boldsymbol{I}-\boldsymbol{B})=1$ ，即 $\boldsymbol{R}(\lambda)=\boldsymbol{R}\in\mathbb{F}^{n\times n}$ 为常数矩阵。因此：</p>
<script type="math/tex; mode=display">
\begin{align}
&\boldsymbol{U}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &[(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)+\boldsymbol{R}](\lambda\boldsymbol{I}-\boldsymbol{A})\boldsymbol{V}(\lambda)=\lambda\boldsymbol{I}-\boldsymbol{B} \notag\\

\Leftrightarrow &\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})] \notag

\end{align}</script><p>比较等式两端变量 $\lambda$ 的系数可知，$\boldsymbol{V}^{-1}(\lambda)-\boldsymbol{Q}(\lambda)(\lambda\boldsymbol{I}-\boldsymbol{A})$ 也是常数矩阵，记作 $\boldsymbol{S}$ ，故而：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})=(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{S}</script><p>且由 $\lambda$ 系数知：$\boldsymbol{R}=\boldsymbol{S}$ ，从而有 $\boldsymbol{RA}=\boldsymbol{BR}$ ，只需证 $\boldsymbol{R}$ 可逆即可</p>
<p>要证明可逆，我们期望找出一个矩阵 $\boldsymbol{P}$ ，使得 $\boldsymbol{RP}=\boldsymbol{I}$ .</p>
<p>考虑到 $\boldsymbol{R}$ 是由矩阵 $\boldsymbol{U}(\lambda)$ 对矩阵 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作带余除法所得，对应地，也可以有：</p>
<script type="math/tex; mode=display">
\boldsymbol{U}^{-1}(\lambda)=(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\widetilde{\boldsymbol{R}}</script><p>将方程 (7) (10) 代入 $\boldsymbol{U}(\lambda)\boldsymbol{U}^{-1}(\lambda)=\boldsymbol{I}$ ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}(\lambda\boldsymbol{I}-\boldsymbol{A})\widetilde{\boldsymbol{Q}}(\lambda)+\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)</script><p>代入方程 (9) ，整理得：</p>
<script type="math/tex; mode=display">
\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}-(\lambda\boldsymbol{I}-\boldsymbol{B})[\boldsymbol{Q}(\lambda)\boldsymbol{U}^{-1}(\lambda)+\boldsymbol{S}\widetilde{\boldsymbol{Q}}(\lambda)]</script><p>比较方程 (12) 两边 $\lambda$ 系数知：$\boldsymbol{R}\widetilde{\boldsymbol{R}}=\boldsymbol{I}$ ，从而 $\boldsymbol{R}$ 可逆。</p>
<p>证毕。</p>
<h5 id="特征矩阵的-Smith-型"><a href="#特征矩阵的-Smith-型" class="headerlink" title="特征矩阵的 Smith 型"></a>特征矩阵的 Smith 型</h5><p>因为 $|\lambda\boldsymbol{I}-\boldsymbol{A}|$ 的最高次项 $\lambda^n$ 的系数必为1，因此，$\lambda\boldsymbol{I}-\boldsymbol{A}$ 作为多项式矩阵的秩为 $n$ 。从而它的Smith型矩阵为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
d_1(\lambda)&\\
&\ddots&\\
&&d_n(\lambda)
\end{bmatrix}</script><p>因此：$d_1(\lambda)\cdots d_n(\lambda)=|\lambda\boldsymbol{I}-\boldsymbol{A}|\Rightarrow\partial(d_1(\lambda))+\cdots+\partial(d_n(\lambda))=n$ 。若某个 $d_i(\lambda)$ 的次数为 $n_i\neq1$ ，那么必将多出 $n_i-1$ 个常数不变因子，根据首1多项式的约定，这些不变因子最终都会化为1。因此上述Smith型矩阵进一步表示为：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1&&&&&\\
&\ddots&&&&\\
&&1&&&\\
&&&h_1(\lambda)&&\\
&&&&\ddots&\\
&&&&&h_p(\lambda)
\end{bmatrix}</script><p>其中，$\partial(h_i(\lambda))=n_i$ 。假设有 $p$ 个非常数不变因子，那么等于1的不变因子共有 $n-p$ 个，且满足 $n-p=(n_1-1)+\cdots+(n_p-1)$ ，因此将对角线上的元素按一个 $h_i(\lambda)$ ，$n_i-1$ 个1配对进行重组，Smith型矩阵等价于如下矩阵：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & h_1(\lambda) & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & h_p(\lambda)
\end{array}
\right]</script><p>每一小块都是 $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ </p>
<ul>
<li><p>特征矩阵的初等因子组</p>
<p>初等因子指的是将特征矩阵的所有非常数不变因子在 $\mathbb{F}[\lambda]$ 中作质因式分解时出现的质因式的方幂。所有初等因子组成初等因子组（显然初等因子组中的某个初等因子可能重复出现）。</p>
<p>$h_i(\lambda)\xlongequal{质因式分解}w_1^{r_{i1}}(\lambda)\cdots w_j^{r_{ij}}(\lambda)$ ，则每个质因式的方幂 $w_j^{r_{ij}}(\lambda)$ 就是一个初等因子，所有方幂组成了特征矩阵的初等因子组。</p>
<p>（实数域中的质因式包括 $x-c$ 和 $x^2+bx+c,且\ b^2-4c&lt;0$ 两种情况；复数域中的质因式只有 $x-c$ 一种情况）</p>
</li>
<li><p>初等因子组与不变因子（行列式因子、初等因子）互相唯一决定</p>
<p>由不变因子决定初等因子组：根据定义，显然</p>
<p>​    <strong>例</strong>：已知矩阵 $\boldsymbol{A}$ 的特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的 Smith型 为：$\begin{bmatrix}1&amp;0&amp;0\\0&amp;(\lambda+1)^2&amp;0\\0&amp;0&amp;\lambda(\lambda+1)^2\end{bmatrix}$ </p>
<p>​    显然初等因子组为：$\{(\lambda+1)^2,\lambda, (\lambda+1)^2\}$</p>
<p>由初等因子组决定不变因子：</p>
<p>​    <strong>例</strong>：设 $\boldsymbol{A}\in\mathbb{C}^{8\times8}$ ，且初等因子组为：$\{\lambda,\lambda^2,\lambda,(\lambda+1)^2,(\lambda+1)^2\}$ ，求不变因子。</p>
<p>​    由于不变因子满足 $d_i(\lambda)|d_{i+1}(\lambda)$ 所以最后一个不变因子的次数应该最高且所有质因式都应出现，以此类推：</p>
<script type="math/tex; mode=display">
\begin{align}
&d_8(\lambda)=\lambda^2(\lambda+1)^2 \notag \\
&d_7(\lambda)=\lambda(\lambda+1)^2 \notag \\
&d_6(\lambda)=\lambda \notag \\
&d_5(\lambda)=\cdots=d_1(\lambda)=1 \notag
\end{align}</script></li>
</ul>
<p>下面通过对非常数不变因子 $h_i(\lambda)$ 在复数域上作质因式分解，将上述（15）进一步化为一种更特殊的形式</p>
<script type="math/tex; mode=display">
h_i(\lambda)=(\lambda-c_1)^{r_1}(\lambda-c_2)^{r_2}\cdots(\lambda-c_k)^{r_k}</script><p>显然有 $r_1+r_2+\cdots+r_k=n_i$ ，逆用初等因子分解，因为子矩阵  $\begin{bmatrix} 1&amp;&amp;&amp;\\&amp;\ddots&amp;&amp;\\&amp;&amp;1&amp;\\&amp;&amp;&amp;h_i(\lambda)\end{bmatrix}_{n_i\times n_i}$ 有上述 $k$ 个初等因子，所以可以等价于（有相同的初等因子组）：</p>
<script type="math/tex; mode=display">
\left[
\begin{array}{cccc|c|cccc}
    1 & & & & & & & & \\
    & \ddots & & & & & & & \\
    & & 1 & & & & & & \\
    & & & (\lambda-c_1)^{r_1} & & & & & \\
    \hline
    & & & & \ddots & & & & \\
    \hline
    & & & & & 1 & & & \\
    & & & & & & \ddots & & \\
    & & & & & & & 1 & \\
    & & & & & & & & (\lambda-c_k)^{r_k}
\end{array}
\right]</script><h5 id="矩阵相似在多项式特征邻域中的各种刻画"><a href="#矩阵相似在多项式特征邻域中的各种刻画" class="headerlink" title="矩阵相似在多项式特征邻域中的各种刻画"></a>矩阵相似在多项式特征邻域中的各种刻画</h5><p>若 $\boldsymbol{A},\boldsymbol{B}\in\mathbb{F}^{n\times n}$ ，则下列结论等价：</p>
<ol>
<li>$\boldsymbol{A}$ 与 $\boldsymbol{B}$ 相似；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 作为多项式矩阵等价；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 Smith型；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 不变因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 行列式因子；</li>
<li>$\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{B}$ 有相同的 初等因子组；</li>
</ol>
<p>例：证明 $\boldsymbol{A}$ 与 $\boldsymbol{A}^T$ 相似</p>
<p>因为只提供了抽象矩阵，所以适用于具体形式的2/3/4/6方法都不容易处理，因此考虑行列式因子</p>
<p>因为 $(\lambda\boldsymbol{I}-\boldsymbol{A})^T=\lambda\boldsymbol{I}-\boldsymbol{A}^T$ ，而矩阵转置行列式不变，因此显然 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 与 $\lambda\boldsymbol{I}-\boldsymbol{A}^T$ 有相同的行列式因子</p>
<h5 id="多项式矩阵等价的证明方法"><a href="#多项式矩阵等价的证明方法" class="headerlink" title="多项式矩阵等价的证明方法"></a>多项式矩阵等价的证明方法</h5><ol>
<li>定义法：初等变换能否转化</li>
<li>相同的行列式因子 / Smith型 / 不变因子 / 初等因子组</li>
</ol>
<h4 id="Jordan标准型"><a href="#Jordan标准型" class="headerlink" title="Jordan标准型"></a>Jordan标准型</h4><p>以下均在复数域上考虑，因而质因式只有 $\lambda-c$ 一种类型。</p>
<p>综合上面所说，特征矩阵可以有如下等价：</p>
<script type="math/tex; mode=display">
\lambda\boldsymbol{I}-\boldsymbol{A}\sim \boldsymbol{J}(\lambda)=
\begin{bmatrix}
\boldsymbol{J}_1(\lambda) &&\\
&\ddots&\\
&&\boldsymbol{J}_q(\lambda)
\end{bmatrix},
\boldsymbol{J}_i(\lambda)=
\begin{bmatrix}
1 &&& \\
& \ddots && \\
&& 1 & \\
&&& (\lambda-c_i)^{r_i}
\end{bmatrix}_{r_i\times r_i}</script><p>其中：$(\lambda-c_i)^{r_i},i=1,…,q$ 是特征矩阵的初等因子组。</p>
<p>从而：$\boldsymbol{A}\longrightarrow\lambda\boldsymbol{I}-\boldsymbol{A}\sim\boldsymbol{J}(\lambda)\sim\lambda\boldsymbol{I}-\boldsymbol{J}\longleftarrow\boldsymbol{J}$ ，满足这个条件的矩阵都与 $\boldsymbol{A}$ 相似</p>
<p>我们要做的，就是求出其中最简单的矩阵，也就是相似最简型</p>
<p>进一步，这个问题又可以拆分成针对各个子块的类似的问题，即：求一个尽可能简单的矩阵 $\boldsymbol{J}_i\in\mathbb{C}^{r_i\times r_i}$ ，使得 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<h5 id="Jordan块的Simth型"><a href="#Jordan块的Simth型" class="headerlink" title="Jordan块的Simth型"></a>Jordan块的Simth型</h5><p>若当块：对角线元素全为 $c_1$ ，次对角线元素均为1的矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_1 & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_1
\end{bmatrix}_{r_i\times r_i}</script><p>结论：若当块所对应特征矩阵的Simth型即满足 $\lambda\boldsymbol{I}_{r_i}-\boldsymbol{J}_i\sim\boldsymbol{J}_i(\lambda)$ </p>
<p>下面给出证明（本质就是证明两个多项式矩阵等价） ：</p>
<ul>
<li>方法一：定义法</li>
</ul>
<script type="math/tex; mode=display">
左边=\begin{bmatrix}
\lambda-c_1 & -1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & -1 \\
0 & \cdots & \cdots& \lambda-c_1
\end{bmatrix}_{r_i\times r_i}</script><ul>
<li>方法二：计算两边的行列式因子</li>
</ul>
<p>由于左边的 $r_i-1$ 阶行列式中有一个是1（右上角子块），所以左边矩阵的 $r_i-1$ 阶最高公因式只能是1，即左边矩阵的 $r_i-1$ 阶行列式因子为1。</p>
<p>从而所有比它低阶的行列式因子也只能是1，因为 $D_{i-1}(\lambda)$ 必须整除 $D_{i}(\lambda)$ 。</p>
<p>而左侧行列式等于右侧行列式，即左侧 $r_i$ 阶行列式因子与右侧相同。</p>
<p>故而两边矩阵的任意阶行列式因子都相同，从而矩阵等价。</p>
<p>综上所述，有如下定理：</p>
<p>给定矩阵 $\boldsymbol{A}\in\mathbb{C}^{n\times n}$ ，其特征矩阵 $\lambda\boldsymbol{I}-\boldsymbol{A}$ 的初等因子组为：$(\lambda-c_1)^{r_1},\cdots,(\lambda-c_q)^{r_q}$ ，取</p>
<script type="math/tex; mode=display">
\boldsymbol{J}_i=\begin{bmatrix}
c_i & 1 & \cdots & 0 \\
\vdots & \ddots & \ddots & \vdots \\
\vdots & & \ddots & 1 \\
0 & \cdots & \cdots& c_i
\end{bmatrix}_{r_i\times r_i}</script><p>则 $\boldsymbol{A}$ 的相似最简型为：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\sim\boldsymbol{J}=
\begin{bmatrix}
J_1 &  \cdots & 0 \\
\vdots & \ddots & \vdots \\
0 & \cdots & J_q
\end{bmatrix}</script><p>而 $\boldsymbol{J}$ 就是矩阵 $\boldsymbol{A}$ 的 Jordan标准型</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/" class="post-title-link" itemprop="url">矩阵分析学习笔记1：线性空间与线性映射</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-27 13:30:03" itemprop="dateCreated datePublished" datetime="2021-05-27T13:30:03+08:00">2021-05-27</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-29 08:45:42" itemprop="dateModified" datetime="2021-05-29T08:45:42+08:00">2021-05-29</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/" itemprop="url" rel="index"><span itemprop="name">矩阵分析</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="Chapter1-线性空间与线性映射"><a href="#Chapter1-线性空间与线性映射" class="headerlink" title="Chapter1 线性空间与线性映射"></a>Chapter1 线性空间与线性映射</h2><h4 id="线性空间"><a href="#线性空间" class="headerlink" title="线性空间"></a>线性空间</h4><h5 id="域-mathbb-F"><a href="#域-mathbb-F" class="headerlink" title="域 $\mathbb{F}$"></a>域 $\mathbb{F}$</h5><p>一个域是一个运算系统，包括一个集合和在集合上定义的两种运算（加法和乘法）且两种运算都满足一定的运算规则</p>
<p>常用域：有理数域 $\mathbb{Q}$ ，实数域 $\mathbb{R}$ ，复数域 $\mathbb{C}$ </p>
<h5 id="二元加法运算"><a href="#二元加法运算" class="headerlink" title="二元加法运算+"></a>二元加法运算+</h5><p>给定非空集合 $\mathbb{V}$ 和域 $\mathbb{F}$ ，若存在映射 $\sigma:\mathbb{V}\times \mathbb{V}\rightarrow \mathbb{V},(\boldsymbol{\alpha},\boldsymbol{\beta})\mapsto\sigma(\boldsymbol{\alpha},\boldsymbol{\beta})$ ，即对集合 $\mathbb{V}$ 中的任意元素 $\boldsymbol{\alpha},\boldsymbol{\beta}$ ，在集合 $\mathbb{V}$ 中都存在唯一元素 $\boldsymbol{\gamma}$ ，使得 $\boldsymbol{\gamma}=\boldsymbol{\alpha}+\boldsymbol{\beta}\in\mathbb{V}$，则称 $\sigma$ 为集合 $\mathbb{V}$ 上的加法 。</p>
<p>注：定义中的 $\times$ 是集合之间的乘法，称为卡氏积/笛卡尔积，指的是从两个集合中任取一个元素组成的所有有序元素对的集合：$\mathbb{S_1}\times\mathbb{S_2}=\{(a,b)|a\in\mathbb{S_1},b\in\mathbb{S_2}\}$ </p>
<h5 id="二元数乘运算-cdot"><a href="#二元数乘运算-cdot" class="headerlink" title="二元数乘运算 $\cdot$"></a>二元数乘运算 $\cdot$</h5><p>给定非空集合 $\mathbb{V}$ 和数域 $\mathbb{F}$ ，若存在映射 $\sigma:\mathbb{V}\times \mathbb{F}\rightarrow \mathbb{V},(\boldsymbol{\alpha},k)\mapsto\sigma(\boldsymbol{\alpha},k)$ ，即对集合 $\mathbb{V}$ 中的任意元素 $\boldsymbol{\alpha}$ 和数域 $\mathbb{F}$ 中的任意元素 $k$ ，在集合 $\mathbb{V}$ 中都存在唯一元素 $\boldsymbol{\gamma}$ ，使得 $\boldsymbol{\gamma}=\boldsymbol{\alpha}\cdot k\in\mathbb{V}$，则称 $\sigma$ 为集合 $\mathbb{V}$ 上的数乘 。</p>
<h5 id="通常的运算规则"><a href="#通常的运算规则" class="headerlink" title="通常的运算规则"></a>通常的运算规则</h5><ol>
<li>加法的运算规则<ul>
<li>交换律：$\boldsymbol{\alpha}+\boldsymbol{\beta}=\boldsymbol{\beta}+\boldsymbol{\alpha}$ </li>
<li>结合律：$(\boldsymbol{\alpha}+\boldsymbol{\beta})+\boldsymbol{\gamma}=\boldsymbol{\alpha}+(\boldsymbol{\beta}+\boldsymbol{\gamma})$ </li>
<li>有零元：$\exists \boldsymbol{e}\in\mathbb{V},s.t.\ \boldsymbol{e}+\boldsymbol{\alpha}=\boldsymbol{\alpha}\ 对\ \forall \boldsymbol{\alpha}\in\mathbb{V}\ 成立$ </li>
<li>有逆元：$对\ \forall\boldsymbol{\alpha}\in\mathbb{V},\exists\boldsymbol{\beta}\in\mathbb{V},s.t.\ \boldsymbol{\alpha}+\boldsymbol{\beta}=\boldsymbol{e},记\ \boldsymbol{\beta}=-\boldsymbol{\alpha}$ </li>
</ul>
</li>
<li>数乘的运算规则<ul>
<li>交换律：$\boldsymbol{\alpha}\cdot k=k\cdot\boldsymbol{\alpha}$ （一般将对列向量数乘的数写在右侧，对行向量数乘的数写在左侧，这样可以和矩阵乘法作类比）</li>
<li>结合律：$(\boldsymbol{\alpha}\cdot k)\cdot l=\boldsymbol{\alpha}\cdot (kl)$ （注：左边做了两次数乘，右边做了一次 $\mathbb{F}$ 中数的乘法和一次数乘）</li>
<li>分配律：$(\boldsymbol{\alpha}+\boldsymbol{\beta})\cdot k=\boldsymbol{\alpha}\cdot k+\boldsymbol{\beta}\cdot k,\quad \boldsymbol{\alpha}\cdot(k_1+k_2)=\boldsymbol{\alpha}\cdot k_1 + \boldsymbol{\alpha}\cdot k_2$ （注：第二个式子左边做的是 $\mathbb{F}$ 中数的加法，右边做的是向量加法）</li>
<li>与 $\mathbb{F}$ 中 1 的关系：$\boldsymbol{\alpha}\cdot 1=\boldsymbol{\alpha}$ </li>
</ul>
</li>
</ol>
<h5 id="线性空间-1"><a href="#线性空间-1" class="headerlink" title="线性空间"></a>线性空间</h5><p>若集合 $\mathbb{V}$ 满足上述两种运算，且这两种运算满足通常的运算规则，则称集合 $\mathbb{V}$ 关于此加法和数乘是域 $\mathbb{F}$ 上的线性空间。（一般也把这种线性空间称为向量空间，$\mathbb{V}$ 中的元素称为向量）</p>
<p>注1：空间这个概念只是为了类比2维或3维几何空间的一个概念，更好的理解为元素的集合，线性空间中的元素统称为<strong>抽象向量</strong> </p>
<p>注2：集合 $\mathbb{V}$ 中的元素分别为数组、函数、有向线段时，对应的线性空间称为数域空间、函数空间、几何空间</p>
<p>注3：数域 $\mathbb{F}$ 上的<strong>标准线性空间</strong> $\mathbb{F}^n$ （数域空间）</p>
<p>​    $\mathbb{V}:=\mathbb{F}^n=\begin{matrix}n\\ \overbrace{\mathbb{F}\times\mathbb{F}\times \cdots\times \mathbb{F} }\end{matrix}$ ，其元素称为 n元组（n-tuple） </p>
<p>​    加法：$\begin{bmatrix}v_1\\ \vdots\\ v_n\end{bmatrix} + \begin{bmatrix}w_1\\ \vdots\\ w_n\end{bmatrix} = \begin{bmatrix}v_1+w_1\\ \vdots\\ v_n+w_n\end{bmatrix}$</p>
<p>​    数乘：$\begin{bmatrix}v_1\\ \vdots\\ v_n\end{bmatrix}\cdot k=\begin{bmatrix}v_1\cdot k\\ \vdots\\ v_n\cdot k\end{bmatrix}$ </p>
<p>​    容易证明，定义的加法和数乘满足上述运算规则</p>
<p>注4：对于<strong>几何空间（有向线段的集合）</strong>，加法运算采用平行四边形或三角形法则进行计算，数乘运算表示对有向线段进行同向或反向伸缩</p>
<h4 id="向量组的线性相关性"><a href="#向量组的线性相关性" class="headerlink" title="向量组的线性相关性"></a>向量组的线性相关性</h4><p>向量组：$\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$</p>
<p>抽象矩阵：$[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]$ </p>
<p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{x}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_p \end{bmatrix}=\boldsymbol{0}</script><p>若无非零解，则向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性无关；若存在非零解，则向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性相关</p>
<h5 id="向量组的线性表出"><a href="#向量组的线性表出" class="headerlink" title="向量组的线性表出"></a>向量组的线性表出</h5><p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{x}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_p \end{bmatrix}=\boldsymbol{\beta}</script><p>若有解，则向量 $\boldsymbol{\beta}$ 可由向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性表出</p>
<p>定义方程组：</p>
<script type="math/tex; mode=display">
\boldsymbol{A}\boldsymbol{X}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_p]
\begin{bmatrix}
    x_{11} &x_{12}\ \ \cdots&x_{1p} \\
    x_{21} &x_{22}\ \ \cdots&x_{2p} \\
    \vdots &\ddots          &\vdots \\ 
    x_{p1} &x_{p2}\ \ \cdots&x_{pp}
\end{bmatrix}
=[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_p]
=\boldsymbol{B}</script><p>若有解，则向量组 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_p$ 可由向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 线性表出</p>
<p>向量组的线性表示具有传递性</p>
<h5 id="有限维线性空间的基（坐标系）与坐标"><a href="#有限维线性空间的基（坐标系）与坐标" class="headerlink" title="有限维线性空间的基（坐标系）与坐标"></a>有限维线性空间的基（坐标系）与坐标</h5><p>设集合 $\mathbb{V}$ 是 数域 $\mathbb{F}$ 上的线性空间，有正整数 $n$ 及 $\mathbb{V}$ 中的向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 满足以下两个条件：</p>
<ul>
<li><p>线性无关性：向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 线性无关</p>
</li>
<li><p>生成性：$\forall \boldsymbol{\alpha} \in \mathbb{V} $ ，均可由 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 线性表出</p>
<script type="math/tex; mode=display">
\boldsymbol{\alpha}=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]\begin{bmatrix}x_1\\x_2\\ \vdots\\ x_n \end{bmatrix}=\boldsymbol{A}\boldsymbol{x}</script></li>
</ul>
<p>则称向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 为 $n$ 维线性空间 $\mathbb{V}$ 的一组基，矩阵 $A=[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]$ 称为基矩阵，向量 $\boldsymbol{x}=[x_1\ x_2\ \cdots\ x_n]^T\in\mathbb{F}^n$ 称为抽象向量 $\boldsymbol{\alpha}$ 在基 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 下的坐标。</p>
<p>换言之，抽象向量 = 基矩阵 $\cdot$ 坐标向量</p>
<p>注1：基向量组的线性无关性保证线性空间中的抽象向量在该基下的坐标是唯一的，生成性保证空间中的任意向量在该基下都有坐标；</p>
<p>注2：基（坐标系）实现了抽象线性空间到标准线性空间的一一对应（通过基实现对抽象向量的具体化）</p>
<h5 id="标准线性空间-mathbb-F-n-的标准基与一般基"><a href="#标准线性空间-mathbb-F-n-的标准基与一般基" class="headerlink" title="标准线性空间 $\mathbb{F}^n$ 的标准基与一般基"></a>标准线性空间 $\mathbb{F}^n$ 的标准基与一般基</h5><p>标准基：</p>
<script type="math/tex; mode=display">
\boldsymbol{e}_1=\begin{bmatrix}1\\0\\\vdots\\0 \end{bmatrix},
\boldsymbol{e}_2=\begin{bmatrix}0\\1\\\vdots\\0 \end{bmatrix}
\boldsymbol{e}_n=\begin{bmatrix}0\\0\\\vdots\\1 \end{bmatrix},
\text{and}\ \boldsymbol{e}_i\in\mathbb{F}^n</script><p>标准基构成的基矩阵是单位矩阵 $\boldsymbol{I}_n=[\boldsymbol{e}_1\ \cdots\ \boldsymbol{e}_n]\in\mathbb{F}^{n\times n}$ </p>
<p>一般基：向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 是一般基 $\Leftrightarrow$ 线性无关 $\Leftrightarrow r(\boldsymbol{A})=n$ ，由一般基构成的基矩阵是<strong>非奇异矩阵</strong> </p>
<h4 id="线性子空间"><a href="#线性子空间" class="headerlink" title="线性子空间"></a>线性子空间</h4><p>设 $\mathbb{V}$ 是 $\mathbb{F}$ 上的线性空间，$\mathbb{W}\subseteq \mathbb{V}$ 是非空子集，若 $\mathbb{W}$ 中的元素也满足加法封闭性和数乘封闭性，则称 $\mathbb{W}$ 是 $\mathbb{V}$ 的一个线性子空间。</p>
<h5 id="向量组的生成子空间和子空间的生成组"><a href="#向量组的生成子空间和子空间的生成组" class="headerlink" title="向量组的生成子空间和子空间的生成组"></a>向量组的生成子空间和子空间的生成组</h5><p>设 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 是线性空间 $\mathbb{V}$ 中的一个向量组，定义集合 $\mathbb{W}$ 如下：  </p>
<script type="math/tex; mode=display">
\mathbb{W}=\text{span}
\{
\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p
\}
=\{
\boldsymbol{\alpha}_1\cdot x_1+\boldsymbol{\alpha}_2\cdot x_2+\cdots+\boldsymbol{\alpha}_p\cdot x_p|\forall x_i\in\mathbb{F}
\}</script><p>称 $\mathbb{W}$ 为向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_p$ 的生成子空间，显然 $\mathbb{W}$ 是 $\mathbb{V}$ 的子空间。</p>
<h5 id="矩阵的核与像"><a href="#矩阵的核与像" class="headerlink" title="矩阵的核与像"></a>矩阵的核与像</h5><p>设矩阵 $\boldsymbol{A}\in \mathbb{F}^{m\times n}$ ，定义矩阵 $\boldsymbol{A}$ 的核（kernel）与像（Image）如下：</p>
<script type="math/tex; mode=display">
\text{ker}\boldsymbol{A}=\{\boldsymbol{x}|\boldsymbol{A}\boldsymbol{x}=\boldsymbol{0},\boldsymbol{x}\in \mathbb{F}^n\} \subseteq \mathbb{F}^n \\
\text{Im}\boldsymbol{A}=\{\boldsymbol{A}\boldsymbol{x}|\forall \boldsymbol{x}\in \mathbb{F}^n\} \subseteq \mathbb{F}^m</script><p>显然，矩阵 $\boldsymbol{A}$ 的核即为齐次线性方程组的<strong>解空间</strong> ，像即为由列向量组张成的<strong>子空间</strong> </p>
<h5 id="子空间的交与和"><a href="#子空间的交与和" class="headerlink" title="子空间的交与和"></a>子空间的交与和</h5><p>设 $\mathbb{U}$ 和 $\mathbb{W}$ 是 $\mathbb{V}$ 的子空间，则</p>
<ul>
<li>$\mathbb{U}\cap\mathbb{W}$ 也是子空间，称为 $\mathbb{U}$ 和 $\mathbb{W}$ 的交（子空间）</li>
<li>$\mathbb{U}+\mathbb{W}=\text{span}\{\mathbb{U},\mathbb{W}\}=\{u+w|\forall u\in\mathbb{U},w\in\mathbb{W}\}$ 也是子空间，称为 $\mathbb{U}$ 和 $\mathbb{W}$ 的和（子空间）</li>
<li><strong>但</strong> $\mathbb{U}\cup\mathbb{W}$ 不一定是子空间！</li>
</ul>
<h4 id="线性映射"><a href="#线性映射" class="headerlink" title="线性映射"></a>线性映射</h4><h5 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h5><p>若 $f:A\rightarrow B$ 是一个映射，则须满足以下两个充要条件：</p>
<ul>
<li>存在性：$\forall a\in A,\exists b\in B$ 与之对应</li>
<li>唯一性：$\forall a\in A$，在 $B$ 中的像 $b$ 是唯一的</li>
</ul>
<h5 id="线性映射，线性变换与线性同构"><a href="#线性映射，线性变换与线性同构" class="headerlink" title="线性映射，线性变换与线性同构"></a>线性映射，线性变换与线性同构</h5><p>设 $\mathbb{V_1},\mathbb{V_2}$ 是域 $\mathbb{F}$ 上的线性空间，$\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2}$ 是映射，若满足以下两个条件：</p>
<ul>
<li>保加性：$\forall v_1,v_2\in\mathbb{V_1},\sigma(v_1+v_2)=\sigma(v_1)+\sigma(v_2)\in\mathbb{V_2}$ </li>
<li>保乘性：$\forall v\in\mathbb{V_1},\sigma(v\cdot k)=\sigma(v)\cdot k\in\mathbb{V_2}$  </li>
</ul>
<p>则称 $\sigma$ 是 $\mathbb{V_1}$ 到 $\mathbb{V_2}$ 的线性映射</p>
<p>若 $\mathbb{V_1}=\mathbb{V_2}=\mathbb{V}$ ，则称 $\sigma$ 为 $\mathbb{V}$ 上的线性变换</p>
<p><strong>线性映射不同空间，线性变换同一空间</strong></p>
<p>若 $\sigma$ 是可逆映射，则称其为线性同构（数学结构相同）。最典型的例子：抽象的线性空间选定基后，与标准线性空间线性同构</p>
<h5 id="矩阵-与-标准线性空间中的线性映射-是等同的"><a href="#矩阵-与-标准线性空间中的线性映射-是等同的" class="headerlink" title="矩阵 与 标准线性空间中的线性映射 是等同的"></a>矩阵 与 标准线性空间中的线性映射 是等同的</h5><ol>
<li><p>矩阵决定线性映射：给定 $\boldsymbol{A}\in\mathbb{F}^{m\times n}$ ，通过右乘列向量可以决定线性映射 $\sigma$ ：</p>
<script type="math/tex; mode=display">
\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2};\ \boldsymbol{x}\mapsto\boldsymbol{y}=\boldsymbol{Ax}</script></li>
<li><p>线性映射决定矩阵：给定线性映射 $\sigma:\mathbb{V_1}\rightarrow\mathbb{V_2}$ ，一定能用某个矩阵 $\boldsymbol{A}$ 表示出来：</p>
<p>设 $\text{dim}(\mathbb{V_1})=n$ ，向量组 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 是空间 $\mathbb{V_1}$ 的一组基；$\text{dim}(\mathbb{V_2})=m$ ，向量组 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 是空间 $\mathbb{V_2}$ 的一组基，则对 $\forall \boldsymbol{x}\in\mathbb{V_1}$ ，根据线性映射的保加性和保乘性，有：</p>
<script type="math/tex; mode=display">
\begin{align}
\sigma(\boldsymbol{x})&=\sigma([\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n]\boldsymbol{x}) \notag\\ &=\sigma(\boldsymbol{\alpha}_1x_1+\boldsymbol{\alpha}_2x_2+\cdots+\boldsymbol{\alpha}_nx_n) \notag\\
&=\sigma(\boldsymbol{\alpha}_1x_1)+\sigma(\boldsymbol{\alpha}_2x_2)+\cdots+\sigma(\boldsymbol{\alpha}_nx_n) \notag \\
&=\sigma(\boldsymbol{\alpha}_1)x_1+\sigma(\boldsymbol{\alpha}_2)x_2+\cdots+\sigma(\boldsymbol{\alpha}_n)x_n \\
&=[\sigma(\boldsymbol{\alpha}_1)\ \sigma(\boldsymbol{\alpha}_2)\ \cdots\ \sigma(\boldsymbol{\alpha}_n) ]\begin{bmatrix}x_1\\x_2\\ \vdots \\x_n \end{bmatrix} \notag \\
&=[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_m]\boldsymbol{Ax} \notag
\end{align}</script><p>称矩阵 $\boldsymbol{A}$ 为线性映射 $\sigma$ 在入口基 $\boldsymbol{\alpha}_1,\boldsymbol{\alpha}_2,\cdots,\boldsymbol{\alpha}_n$ 与出口基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的矩阵表示，写作：</p>
<script type="math/tex; mode=display">
\sigma[\boldsymbol{\alpha}_1\ \boldsymbol{\alpha}_2\ \cdots\ \boldsymbol{\alpha}_n] =[\boldsymbol{\beta}_1\ \boldsymbol{\beta}_2\ \cdots\ \boldsymbol{\beta}_m]\boldsymbol{A}</script><p>线性映射 $\sigma$ 也可以用某个矩阵表示，即：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}线性\\映射\end{bmatrix}
\begin{bmatrix}入\\口\\基\end{bmatrix}=
\begin{bmatrix}出\\口\\基\end{bmatrix}
\begin{bmatrix}矩阵\\表示\end{bmatrix}</script><p>第 $i$ 列表示基向量 $\boldsymbol{\alpha}_i$ 在基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的坐标；像 $\sigma(\boldsymbol{x})$ 在基 $\boldsymbol{\beta}_1,\boldsymbol{\beta}_2,\cdots,\boldsymbol{\beta}_m$ 下的坐标为：</p>
<script type="math/tex; mode=display">
\boldsymbol{y}=\begin{bmatrix}y_1\\y_2\\ \vdots \\y_m \end{bmatrix}=\boldsymbol{A}\begin{bmatrix}x_1\\x_2\\ \vdots \\ \vdots \\x_n \end{bmatrix}=\boldsymbol{Ax}</script></li>
</ol>
<ul>
<li><p>从线性变换看旋转矩阵</p>
<p><img src="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/1622124672475.png" alt="从线性变换看旋转矩阵"></p>
</li>
</ul>
<h4 id="矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）"><a href="#矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）" class="headerlink" title="矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）"></a>矩阵等价与矩阵相似（重点：用线性空间和线性映射的观点重新认知）</h4><p>设矩阵 $\boldsymbol{A} ,\boldsymbol{B}\in\mathbb{F}^{m\times n}$ ，若存在可逆矩阵 $\boldsymbol{P}\in\mathbb{F}^{n\times n},\boldsymbol{Q}\in\mathbb{F}^{m\times m}$ ，使得 $\boldsymbol{AP}=\boldsymbol{QB}$ ，则称矩阵 $\boldsymbol{A},\boldsymbol{B}$ 等价；进一步，若 $m=n$ ，且 $\boldsymbol{AP}=\boldsymbol{PB}$ ，则称$\boldsymbol{A},\boldsymbol{B}$ 相似。</p>
<p><strong>从几何角度理解矩阵等价与几何相似</strong>（进一步理解公式11）</p>
<p>​    将 $\boldsymbol{A}$ 视为标准线性空间 $\mathbb{F}^n$ 到 $\mathbb{F}^m$ 的线性映射：$\ \boldsymbol{x}\mapsto\boldsymbol{y}=\boldsymbol{Ax}$ （具体矩阵抽象化）或视为某组未知入口基和出口基下的矩阵表示（不妨都取为标准基 $\boldsymbol{E_n},\boldsymbol{E_m}$ ）</p>
<p>​    由 $\boldsymbol{P},\boldsymbol{Q}$ 可逆 $\Rightarrow$ 其列向量可视为 $\mathbb{F}^n$ / $\mathbb{F}^m$ 空间中的两个一般基矩阵。称 $\boldsymbol{P}=[p_1\ p_2\ \cdots\ p_n]$ 为入口基，$\boldsymbol{Q}=[q_1\ q_2\ \cdots q_m]$ 为出口基。</p>
<p>​    由于 $\boldsymbol{AP}=\boldsymbol{QB}$ ，所以有下图成立，等式左右均表示从一般基P下的坐标到标准基下的坐标的线性映射。</p>
<p><img src="/%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90/%E5%93%88%E5%B7%A5%E5%A4%A7-%E4%B8%A5%E8%B4%A8%E5%BD%AC-%E7%9F%A9%E9%98%B5%E5%88%86%E6%9E%90-%E7%AC%AC%E4%B8%80%E8%AE%B2-%E7%BA%BF%E6%80%A7%E7%A9%BA%E9%97%B4%E4%B8%8E%E7%BA%BF%E6%80%A7%E6%98%A0%E5%B0%84/BFC87F8FC976B8B996157EB9E1405F6F.png" alt="img"></p>
<p>​    因此，<strong>矩阵等价</strong>的几何意义为：线性映射 $\boldsymbol{A}$ 在入口基 $\boldsymbol{P}$ 和出口基 $\boldsymbol{Q}$ 下的矩阵表示为 $\boldsymbol{B}$ ，换言之，相当于同一<strong>线性映射</strong>在不同基下的矩阵表示。</p>
<p>​    进一步，当 $m=n$ ，即在线性映射的两个空间是同一个空间的情况下，<strong>矩阵相似</strong>的几何意义为：同一<strong>线性变换</strong>在不同基下的矩阵表示。</p>
<h5 id="方阵-线性变换-的不变子空间"><a href="#方阵-线性变换-的不变子空间" class="headerlink" title="方阵(线性变换)的不变子空间"></a>方阵(线性变换)的不变子空间</h5><p>设方阵 $\boldsymbol{A}\in\mathbb{F}^{n\times n}$ ，子空间 $\mathbb{W}\subseteq\mathbb{F}^n$ ，若满足 $\boldsymbol{A}(\mathbb{W})=\{\boldsymbol{Ax}|\boldsymbol{x}\in\mathbb{W}\}\subseteq\mathbb{W}$ ，即线性变换 $\boldsymbol{A}$ 作用在子空间 $\mathbb{W}$ 上的元素的像依然在子空间 $\mathbb{W}$ 中，则称 $\mathbb{W}$ 是 $\boldsymbol{A}$ 的不变子空间。典型的不变子空间包括：$\{0\},\mathbb{F}^n,\text{ker}(\boldsymbol{A}),\text{im}(\boldsymbol{A})$ </p>
<p><strong>不变子空间等同于相似三角化</strong> </p>
<p>对相似方阵 $\boldsymbol{A},\boldsymbol{B}\in\mathbb{F}^{n\times n}$ ，有可逆矩阵 $\boldsymbol{P}$ 使得 $\boldsymbol{AP}=\boldsymbol{PB}$  ，将矩阵 $\boldsymbol{P}$ 写作分块矩阵 $\boldsymbol{P}=[\boldsymbol{P_{1,n\times n_1}}|\boldsymbol{P_{2,n\times (n-n_1)}} ]$ ，<strong>对应地</strong>，将矩阵 $\boldsymbol{B}$ 写作分块矩阵：</p>
<script type="math/tex; mode=display">
\boldsymbol{B}=\left[
\begin{array}{c|c}
    \boldsymbol{B}_{11,n_1\times n_1} & \boldsymbol{B}_{12,n_1\times(n-n_1)} \\
    \hline
    \boldsymbol{B}_{21,(n-n_1)\times n_1} & \boldsymbol{B}_{22,(n-n_1)\times(n-n_1)}
\end{array}
\right]</script><p>则：</p>
<ul>
<li>$\boldsymbol{B}_{21}=\boldsymbol{0}\Leftrightarrow\text{im}\boldsymbol{P_1}$ 是 $\boldsymbol{A}$ 的不变子空间（上三角化）</li>
<li>$\boldsymbol{B}_{12}=\boldsymbol{0}\Leftrightarrow\text{im}\boldsymbol{P_2}$ 是 $\boldsymbol{A}$ 的不变子空间（下三角化）</li>
</ul>
<p>下面给出证明：</p>
<script type="math/tex; mode=display">
\boldsymbol{AP_1}=[\boldsymbol{P_1}|\boldsymbol{P_2}]
\begin{bmatrix}
    \boldsymbol{B_{11}}\\
    \boldsymbol{B_{21}}
\end{bmatrix}</script><p>即：</p>
<script type="math/tex; mode=display">
\boldsymbol{AP_1}=\boldsymbol{P_1B_{11}}+\boldsymbol{P_2B_{21}}</script><p>若 $\boldsymbol{B_{21}}=\boldsymbol{0}$ ，则 $\boldsymbol{AP_1}=\boldsymbol{P_1B_{11}}$ ，即 $\boldsymbol{A}\cdot\boldsymbol{p_{1j}}$ 均可由 $\boldsymbol{P_1}$ 的列向量的线性组合表出，而 $\boldsymbol{P_1}$ 的列向量的所有线性组合即为 $\text{im}\boldsymbol{P_1}\subseteq\mathbb{F}^{n_1}\subseteq\mathbb{F}^n$  ，从而 $\boldsymbol{A}$ 作用在子空间 $\text{im}\boldsymbol{P_1}$ 上的元素的像依然在子空间 $\text{im}\boldsymbol{P_1}$ 中，因此结论成立。</p>
<p><strong>从不变子空间到相似三角化</strong></p>
<p>给定方阵 $\boldsymbol{A}$ 和子空间 $\mathbb{W}$ ，求矩阵 $\boldsymbol{P}$ 使得相似矩阵 $\boldsymbol{B}$ 块三角化。</p>
<p>$\Leftrightarrow$ 将 $\mathbb{W}$ 的 $n_1$ 个基向量扩充为 $\mathbb{F}^n$ 的一组基（因为 $\boldsymbol{P}$ 可逆），由这组基组成所求矩阵 $\boldsymbol{P}$ </p>
<p><strong>从相似三角化到不变子空间</strong> </p>
<p>给定矩阵 $\boldsymbol{P}$ ，求不变子空间 $\mathbb{W}$ 。</p>
<p>根据不变子空间的维数 $n_1$ ，取 $\boldsymbol{P}$ 的前 $n_1$ 列向量张成即可。</p>
<h5 id="从一维不变子空间看特征向量"><a href="#从一维不变子空间看特征向量" class="headerlink" title="从一维不变子空间看特征向量"></a>从一维不变子空间看特征向量</h5><p>特征向量满足： $\boldsymbol{A}\boldsymbol{p}=\boldsymbol{p}\lambda,\boldsymbol{A}\in\mathbb{F}^{n\times n},\boldsymbol{p}\in\mathbb{F}^n,\lambda\in\mathbb{F}$ ，显然等式右侧向量也在子空间 $\text{im}\boldsymbol{p}$ 中，所以 $\text{im}\boldsymbol{p}$ 为 $\boldsymbol{A}$ 的一维不变子空间。</p>
<p>即，矩阵的一维不变子空间对应的向量即为特征向量，特征向量对应的特征值可以不只一个。</p>
<h5 id="相似对角化的充要条件"><a href="#相似对角化的充要条件" class="headerlink" title="相似对角化的充要条件"></a>相似对角化的充要条件</h5><p>由上可知，$\boldsymbol{P}=[\boldsymbol{p}_1\ \cdots \ \boldsymbol{p}_n]$ ，因此：</p>
<p>可以相似对角化 $\Leftrightarrow\forall j,\ \text{im}\boldsymbol{p}_j$ 是 $\boldsymbol{A}$ 的不变子空间 $\Leftrightarrow\forall j,\boldsymbol{p}_j$ 是 $\boldsymbol{A}$ 的特征向量 $\Leftrightarrow$ 矩阵 $\boldsymbol{A}$ 有 $n$ 个线性无关的特征向量 $\Leftrightarrow$ 矩阵 $\boldsymbol{A}$ 有一组由特征向量构成的基</p>
<p><strong>从几何角度理解相似对角化</strong>，上述结论也是显然的：</p>
<script type="math/tex; mode=display">
\begin{align}
\boldsymbol{P}^{-1}\boldsymbol{AP}=\boldsymbol{\Lambda}&\Leftrightarrow\boldsymbol{AP}=\boldsymbol{P\Lambda} \notag \\

&\Leftrightarrow\boldsymbol{A}[\boldsymbol{p}_1\cdots\boldsymbol{p}_n]=[\boldsymbol{p}_1\cdots\boldsymbol{p}_n]
\begin{bmatrix}
\lambda_1 & \cdots & 0 \\
\vdots    & \ddots & \vdots \\
0          & \cdots & \lambda_n
\end{bmatrix} \\

&\Leftrightarrow\forall j,\boldsymbol{A}\boldsymbol{p}_j=\boldsymbol{p}_j\lambda_j \notag
\end{align}</script><h5 id="从相似最简型问题到-lambda-矩阵的Jordan标准型"><a href="#从相似最简型问题到-lambda-矩阵的Jordan标准型" class="headerlink" title="从相似最简型问题到$\lambda$ 矩阵的Jordan标准型"></a>从相似最简型问题到$\lambda$ 矩阵的Jordan标准型</h5><p>并不是所有矩阵都有 $n$ 个特征向量，即并不是所有矩阵都能相似对角化，对于不能相似对角化的矩阵，我们提出 <code>Jordan(若当)标准型</code> 的概念。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E7%A8%80%E7%96%8F%E7%9F%A9%E9%98%B5%E6%93%8D%E4%BD%9C/" class="post-title-link" itemprop="url">稀疏矩阵操作</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-27 01:38:41 / 修改时间：01:48:33" itemprop="dateCreated datePublished" datetime="2021-05-27T01:38:41+08:00">2021-05-27</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/" class="post-title-link" itemprop="url">线性代数与稠密矩阵分解</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-05-24 21:57:47" itemprop="dateCreated datePublished" datetime="2021-05-24T21:57:47+08:00">2021-05-24</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-27 01:20:54" itemprop="dateModified" datetime="2021-05-27T01:20:54+08:00">2021-05-27</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍如何利用不同的矩阵分解方法（LU，QR，SVD，特征分解等）求解线性系统</p>
<h4 id="矩阵分解"><a href="#矩阵分解" class="headerlink" title="矩阵分解"></a>矩阵分解</h4><p>矩阵分解（decomposition/factorization）是指将矩阵拆分为若干矩阵的乘积，包括三角分解（LU）、满秩分解、QR分解、Jordan分解和奇异值分解（SVD）等。Eigen提供了常用的三种矩阵分解：LU、QR、SVD</p>
<h5 id="三角分解-LU"><a href="#三角分解-LU" class="headerlink" title="三角分解 LU"></a>三角分解 LU</h5><script type="math/tex; mode=display">
A=LU</script><p>将原方阵（square matrix）分解成一个上三角矩阵和一个下三角形矩阵。主要用于简化一个大矩阵的行列式的计算、求逆矩阵、求解方程组。这种分解法所得到的上下三角形矩阵并非唯一。</p>
<h5 id="LLT分解（Cholesky分解）"><a href="#LLT分解（Cholesky分解）" class="headerlink" title="LLT分解（Cholesky分解）"></a>LLT分解（Cholesky分解）</h5><p>若A为<strong>正定矩阵</strong>，则A有如下唯一的分解形式：</p>
<script type="math/tex; mode=display">
A=LL^*</script><p>其中 $L$ 为下三角矩阵，$L^<em>$ 为其共轭转置矩阵，当A为实矩阵时，$L^</em>=L^T$ </p>
<h5 id="LDLT分解"><a href="#LDLT分解" class="headerlink" title="LDLT分解"></a>LDLT分解</h5><p>若A为一<strong>对称矩阵</strong>且其任意<strong>k阶主子阵均不为零</strong>，即半正定或半负定，则A有如下惟一的分解形式：</p>
<script type="math/tex; mode=display">
A=LDL^T</script><p>其中 $L$ 为下三角形单位矩阵（即主对角线元素皆为1），$D$ 为对角矩阵，$L^T$ 为 $L$ 的转置矩阵。LDLT分解法是Cholesky分解法的改进，Cholesky分解法虽然不需要选主元，但其运算过程中涉及到开方问题，而LDLT分解法则避免了这一问题，可用于求解线性方程组。</p>
<h5 id="QR分解"><a href="#QR分解" class="headerlink" title="QR分解"></a>QR分解</h5><p>对列向量线性无关的矩阵 A ：</p>
<script type="math/tex; mode=display">
A=QR</script><p>其中，$Q$ 为 $m\times m$ 的酉矩阵（实数域内称为正交矩阵），$R$ 为上三角矩阵</p>
<h5 id="奇异值分解-SVD"><a href="#奇异值分解-SVD" class="headerlink" title="奇异值分解 SVD"></a>奇异值分解 SVD</h5><p>对任意矩阵 A：</p>
<script type="math/tex; mode=display">
A=U\Sigma V^*</script><p>其中 $U$ 和 $V$ 均为酉矩阵（实数域内称为正交矩阵，$V^*=V^T$）且不唯一， $\Sigma$ 为对角矩阵，对角线上的元素称为A的奇异值。用于解最小二乘和数据压缩。</p>
<h4 id="用矩阵分解求解线性方程组"><a href="#用矩阵分解求解线性方程组" class="headerlink" title="用矩阵分解求解线性方程组"></a>用<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__TopicLinearAlgebraDecompositions.html">矩阵分解</a>求解线性方程组</h4><p>Eigen为矩阵提供了如图所示的分解方法，调用第二列的方法后会返回一个第一列对应的类对象，再通过调用该对象的 <code>solve()</code> 方法实现对方程的求解，具体见后文代码示例。</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224931096.png" alt="矩阵分解函数"></p>
<h5 id="LU-分解"><a href="#LU-分解" class="headerlink" title="LU 分解"></a>LU 分解</h5><ul>
<li><p><strong>partialPivLu()</strong></p>
<p>基于部分消元的LU分解（必须是可逆方阵）。$A=PLU$ ，其中 $L$ 为单位下三角矩阵，$U$ 为上三角矩阵，$P$ 为置换矩阵，即只进行行变换</p>
</li>
<li><p><strong>fullPivLu()</strong></p>
<p>基于全消元的LU分解（对任意矩阵）。$A=P^{-1}LUQ^{-1}$ ，$L,U,P$ 同上，$Q$ 为置换矩阵，即同时进行行变换和列变换。速度比部分消元慢</p>
</li>
<li><p><strong>llt()</strong></p>
<p>标准Cholesky分解（必须是对称正定矩阵）。$A=LL^*$</p>
</li>
<li><p><strong>ldlt()</strong> </p>
<p>有主元的鲁棒Cholesky分解（必须是半正定或半负定矩阵）。$A=P^TLDL^*P$ </p>
</li>
</ul>
<h5 id="QR-分解"><a href="#QR-分解" class="headerlink" title="QR 分解"></a>QR 分解</h5><ul>
<li><p><strong>householderQr()</strong> </p>
<p>使用 <code>Househoder</code> 变换实现 $A=QR$ 的分解，其中 $Q$ 为酉矩阵，$R$ 为上三角矩阵。无主元，快，但不稳定</p>
</li>
<li><p><strong>colPivHouseholderQr()</strong> </p>
<p>基于行变换（列主元消元法）的 <code>Householder</code> 变换，$AP=QR$ 。较慢，但更精确</p>
</li>
<li><p><strong>fullPivHouseholderQr()</strong> </p>
<p>同时进行行变换和列变换的 <code>Householder</code> 变换，$PAP’=QR$ 。最慢，但最稳定</p>
</li>
<li><p><strong>completeOrthogonalDecomposition()</strong> </p>
<p>完全正交分解。可以看作是QR分解的推广</p>
</li>
</ul>
<h5 id="SVD-分解"><a href="#SVD-分解" class="headerlink" title="SVD 分解"></a>SVD 分解</h5><ul>
<li><p><strong>bdcSvd()</strong> </p>
<p>最快的SVD算法（推荐使用）</p>
</li>
<li><p><strong>jacobiSvd()</strong> </p>
<p>对小矩阵速度快，大矩阵慢</p>
</li>
</ul>
<p><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__DenseDecompositionBenchmark.html">表格</a>给出了上述所有分解方法的效率对比 </p>
<p>代码示例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Eigen&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctime&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MATRIX_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">/* 假设矩阵A为方阵，待求解方程为 Ax=b */</span></span><br><span class="line">     <span class="comment">// 首先定义一个随机矩阵A，随机列向量b和待求解向量x</span></span><br><span class="line">     MatrixXd A;</span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; b;</span><br><span class="line">     A = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, MATRIX_SIZE);</span><br><span class="line">     b = MatrixXd::<span class="built_in">Random</span>(MATRIX_SIZE, <span class="number">1</span>);</span><br><span class="line">     <span class="comment">// 定义时间变量，方便比较效率</span></span><br><span class="line">     <span class="keyword">clock_t</span> <span class="keyword">start_t</span>;</span><br><span class="line">     <span class="keyword">double</span> time;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法一：直接右乘A的逆矩阵 x = A^&#123;-1&#125;*b */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_inv;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_inv = A.<span class="built_in">inverse</span>()*b;</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_inv = &quot;</span> &lt;&lt; x_inv.<span class="built_in">transpose</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法二：普通LU分解 </span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种LU分解的方法</span></span><br><span class="line"><span class="comment">      * - partialPivLu(): A = PLU -&gt; 要求A必须可逆</span></span><br><span class="line"><span class="comment">      * - fullPivLu(): A = P^&#123;-1&#125;LUQ^&#123;-1&#125;</span></span><br><span class="line"><span class="comment">      * - llt(): A = LL^T -&gt; 要求A必须对称正定</span></span><br><span class="line"><span class="comment">      * - ldlt(): A = LDL^T -&gt; 要求A必须半正定或半负定</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 2.1 partialPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_plu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_plu = A.<span class="built_in">partialPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_plu = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 2.2 fullPivLu()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_flu;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_flu = A.<span class="built_in">fullPivLu</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_flu = &quot;</span> &lt;&lt; x_flu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法三：LLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_llt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     <span class="comment">// 因为llt分解要求 A 必须为正定矩阵，所以构造新的方程：(A^T*A)*x = A^T*b 来求解x</span></span><br><span class="line">     x_llt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_llt = &quot;</span> &lt;&lt; x_llt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法四：LDLT分解 */</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_ldlt;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_ldlt = (A.<span class="built_in">transpose</span>()*A).<span class="built_in">llt</span>().<span class="built_in">solve</span>(A.<span class="built_in">transpose</span>()*b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_ldlt = &quot;</span> &lt;&lt; x_ldlt.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法五：QR分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了四种QR分解的方法</span></span><br><span class="line"><span class="comment">      * - householderQr()</span></span><br><span class="line"><span class="comment">      * - colPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - fullPivHouseholderQr()</span></span><br><span class="line"><span class="comment">      * - completeOrthogonalDecomposition()</span></span><br><span class="line"><span class="comment">      * 常用2和3</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 5.1 colPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_cqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_cqr = A.<span class="built_in">colPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_cqr = &quot;</span> &lt;&lt; x_cqr.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 5.2 fullPivHhouseholderQr()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_fqr;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_fqr = A.<span class="built_in">fullPivHouseholderQr</span>().<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_fqr = &quot;</span> &lt;&lt; x_plu.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line"></span><br><span class="line">     <span class="comment">/* 方法六：SVD分解</span></span><br><span class="line"><span class="comment">      * Eigen 提供了两种SVD分解方法</span></span><br><span class="line"><span class="comment">      * - bdcSvd()</span></span><br><span class="line"><span class="comment">      * - jacobiSvd()</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">     <span class="comment">// 6.1 bdcSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_bsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_bsvd = A.<span class="built_in">bdcSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_bsvd = &quot;</span> &lt;&lt; x_bsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">     <span class="comment">// 6.2 jacobiSvd()</span></span><br><span class="line">     Matrix&lt;<span class="keyword">double</span>, MATRIX_SIZE, <span class="number">1</span>&gt; x_jsvd;</span><br><span class="line">     <span class="keyword">start_t</span> = <span class="built_in">clock</span>();</span><br><span class="line">     x_jsvd = A.<span class="built_in">jacobiSvd</span>(ComputeThinU|ComputeThinV).<span class="built_in">solve</span>(b);</span><br><span class="line">     time = <span class="number">1000</span> * (<span class="built_in">clock</span>() - <span class="keyword">start_t</span>) / (<span class="keyword">double</span>)CLOCKS_PER_SEC;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd time = &quot;</span> &lt;&lt; time &lt;&lt; <span class="string">&quot; ms&quot;</span> &lt;&lt; endl;</span><br><span class="line">     cout &lt;&lt; <span class="string">&quot;x_jsvd = &quot;</span> &lt;&lt; x_jsvd.<span class="built_in">transpose</span>() &lt;&lt; endl; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>计算结果：</p>
<p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210526224615007.png" alt="计算结果"></p>
<h4 id="计算特征值与特征向量"><a href="#计算特征值与特征向量" class="headerlink" title="计算特征值与特征向量"></a>计算特征值与特征向量</h4><p><img src="/Eigen/%E7%BA%BF%E6%80%A7%E4%BB%A3%E6%95%B0%E4%B8%8E%E5%88%86%E8%A7%A3/image-20210527002238291.png" alt="image-20210527002238291"></p>
<p>如图，Eigen为矩阵提供了四种<strong>特征分解</strong>的方法，第二列表示适用矩阵的条件，第三四列分别表示运算速度和精度</p>
<p>以 <code>SelfAdjointEigenSolver</code> 为例，代码如下，其中 <code>info()</code> 函数用来检查特征值/特征向量是否收敛：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">SelfAdjointEigenSolver&lt;Matrix2f&gt; <span class="title">eigensolver</span><span class="params">(A)</span></span>;</span><br><span class="line">   <span class="keyword">if</span> (eigensolver.<span class="built_in">info</span>() != Success) <span class="built_in">abort</span>();</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The eigenvalues of A are:\n&quot;</span> &lt;&lt; eigensolver.<span class="built_in">eigenvalues</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here&#x27;s a matrix whose columns are eigenvectors of A \n&quot;</span></span><br><span class="line">        &lt;&lt; <span class="string">&quot;corresponding to these eigenvalues:\n&quot;</span></span><br><span class="line">        &lt;&lt; eigensolver.<span class="built_in">eigenvectors</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运算结果如下：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2</span><br><span class="line">2 3</span><br><span class="line">The eigenvalues of A are:</span><br><span class="line">-0.236</span><br><span class="line">  4.24</span><br><span class="line">Here<span class="string">&#x27;s a matrix whose columns are eigenvectors of A </span></span><br><span class="line"><span class="string">corresponding to these eigenvalues:</span></span><br><span class="line"><span class="string">-0.851 -0.526</span></span><br><span class="line"><span class="string"> 0.526 -0.851</span></span><br></pre></td></tr></table></figure>
<h4 id="计算逆矩阵与行列式"><a href="#计算逆矩阵与行列式" class="headerlink" title="计算逆矩阵与行列式"></a>计算逆矩阵与行列式</h4><p>尽管逆和行列式是基本的数学概念，但它们在数值线性代数中不像在纯数学中那么常用。求逆通常由 <code>solve()</code> 代替，而行列式一般并不是检测矩阵是否可逆的好方法。不过对于比较小的矩阵，逆和行列式还是比较有用的。</p>
<p>尽管Eigen提供了上述矩阵分解的方法，我们仍然可以直接调用 <code>inverse()</code> 方法和 <code>determinant()</code> 方法。若矩阵尺寸较小（不超过4x4），那么Eigen可以避免使用LU分解，而是使用数学公式，这样更高效。</p>
<h4 id="求解最小二乘"><a href="#求解最小二乘" class="headerlink" title="求解最小二乘"></a><a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__LeastSquares.html">求解最小二乘</a></h4><p>求解最小二乘最精确的方法是使用SVD分解。Eigen提供了两种方法（见上文），推荐使用 <code>bdcSvd()</code> ，对大规模问题友好，同时对小规模问题能自动降级到 <code>jacobiSvd()</code> 方法；</p>
<p>另一种方法是使用 <code>Cholesky</code> 分解或 <code>QR</code> 分解，速度可能会快点，但准确率会下降；</p>
<p>第三种方法是将方程转化为 $A^TAx=A^Tb$ 并使用 <code>ldlt()</code> 方法求解。不过，如果 A 是一个病态矩阵的话，这种方法就不会太好，因为 $A^TA$ 的条件数是 $A$ 的平方，这意味着这种方法会比其他方法损失两倍数值。</p>
<h4 id="将求解和构造分开"><a href="#将求解和构造分开" class="headerlink" title="将求解和构造分开"></a>将求解和构造分开</h4><p>上面的例子将矩阵分解对象的构造和计算写在同一句中，当然也有方法将它们分开写，每种矩阵分解类都有一个默认的构造函数和一个 <code>compute(matrix)</code> 方法，该方法可以对不同的 <code>matrix</code> 重复调用：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2f A, b;</span><br><span class="line">   LLT&lt;Matrix2f&gt; llt;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">3</span>;</span><br><span class="line">   b &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">1</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the right hand side b:\n&quot;</span> &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">   <span class="built_in">A</span>(<span class="number">1</span>,<span class="number">1</span>)++;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The matrix A is now:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Computing LLT decomposition...&quot;</span> &lt;&lt; endl;</span><br><span class="line">   llt.<span class="built_in">compute</span>(A);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The solution is now:\n&quot;</span> &lt;&lt; llt.<span class="built_in">solve</span>(b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  3</span><br><span class="line">Here is the right hand side b:</span><br><span class="line">1 2</span><br><span class="line">3 1</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is:</span><br><span class="line">1.2 1.4</span><br><span class="line">1.4 0.8</span><br><span class="line">The matrix A is now:</span><br><span class="line"> 2 -1</span><br><span class="line">-1  4</span><br><span class="line">Computing LLT decomposition...</span><br><span class="line">The solution is now:</span><br><span class="line">    1  1.29</span><br><span class="line">    1 0.571</span><br></pre></td></tr></table></figure>
<p>也可以通过向构造函数中传入矩阵大小来预分配分解矩阵所需要的内存空间大小：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HouseholderQR&lt;MatrixXf&gt; <span class="title">qr</span><span class="params">(<span class="number">50</span>,<span class="number">50</span>)</span></span>;</span><br><span class="line">MatrixXf A = MatrixXf::<span class="built_in">Random</span>(<span class="number">50</span>,<span class="number">50</span>);</span><br><span class="line">qr.<span class="built_in">compute</span>(A); <span class="comment">// no dynamic memory allocation</span></span><br></pre></td></tr></table></figure>
<h4 id="秩显式分解"><a href="#秩显式分解" class="headerlink" title="秩显式分解"></a>秩显式分解</h4><p>某些分解方法可以同时计算出矩阵的秩，这些通常也是在面对非满秩矩阵（方阵时称为奇异矩阵）时表现最好的方法。包括 <code>FullPivLU</code> 、<code>ColPivHouseholderQR</code> 、<code>FullPivHouseholderQR</code> 、<code>BDCSVD</code> 、<code>JacobiSVD</code> 、<code>SelfAdjointEigenSolver</code> 、<code>ComplexEigenSolver</code> 和 <code>EigenSolver</code> </p>
<p>这些分解类至少提供了一个 <code>rank()</code> 方法用来求矩阵的秩。此外，还提供了一些方便的方法，例如 <code>isInvertible()</code> ；有些还提供了计算矩阵的内核(零空间)和图像(列空间)方法，例如 <code>FullPivLU</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix3f A;</span><br><span class="line">   A &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">1</span>, <span class="number">4</span>,</span><br><span class="line">        <span class="number">3</span>, <span class="number">0</span>, <span class="number">3</span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is the matrix A:\n&quot;</span> &lt;&lt; A &lt;&lt; endl;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix3f&gt; <span class="title">lu_decomp</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;The rank of A is &quot;</span> &lt;&lt; lu_decomp.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the null-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">kernel</span>() &lt;&lt; endl;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Here is a matrix whose columns form a basis of the column-space of A:\n&quot;</span></span><br><span class="line">        &lt;&lt; lu_decomp.<span class="built_in">image</span>(A) &lt;&lt; endl; <span class="comment">// yes, have to pass the original A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix A:</span><br><span class="line">1 2 5</span><br><span class="line">2 1 4</span><br><span class="line">3 0 3</span><br><span class="line">The rank of A is 2</span><br><span class="line">Here is a matrix whose columns form a basis of the null-space of A:</span><br><span class="line"> 0.5</span><br><span class="line">   1</span><br><span class="line">-0.5</span><br><span class="line">Here is a matrix whose columns form a basis of the column-space of A:</span><br><span class="line">5 1</span><br><span class="line">4 2</span><br><span class="line">3 3</span><br></pre></td></tr></table></figure>
<p>当然，任何秩计算都取决于对随机阈值的选择，因为实际上没有哪个浮点矩阵是完全秩亏的。Eigen会选择一个合理的默认阈值。我们也可以自己设定想要的正确阈值：在调用 <code>rank()</code> 或任何其他需要使用这个阈值的方法之前，调用 <code>setThreshold()</code> 来设置阈值。分解计算本身，即 <code>compute()</code> 方法，与阈值选取无关，所以在改变阈值之后，不需要重新计算矩阵分解。</p>
<p>例：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   Matrix2d A;</span><br><span class="line">   A &lt;&lt; <span class="number">2</span>, <span class="number">1</span>,</span><br><span class="line">        <span class="number">2</span>, <span class="number">0.9999999999</span>;</span><br><span class="line">   <span class="function">FullPivLU&lt;Matrix2d&gt; <span class="title">lu</span><span class="params">(A)</span></span>;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;By default, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">   lu.<span class="built_in">setThreshold</span>(<span class="number">1e-5</span>);</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;With threshold 1e-5, the rank of A is found to be &quot;</span> &lt;&lt; lu.<span class="built_in">rank</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">By default, the rank of A is found to be 2</span><br><span class="line">With threshold 1e-5, the rank of A is found to be 1</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E6%B7%B7%E5%8F%A0%E9%97%AE%E9%A2%98-Aliasing/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E6%B7%B7%E5%8F%A0%E9%97%AE%E9%A2%98-Aliasing/" class="post-title-link" itemprop="url">混叠问题(Aliasing)</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-05-24 08:25:49 / 修改时间：21:47:10" itemprop="dateCreated datePublished" datetime="2021-05-24T08:25:49+08:00">2021-05-24</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>混叠问题指的是在进行赋值操作的时候，赋值表达式的两边存在重叠的矩阵区域，例如 <code>mat = 2*mat;</code> 或 <code>mat = mat.transpose();</code> 。前一个表达式中的混叠问题不会对结果产生影响，但后一个表达式中的混叠问题会导致不可预料的结果。本节将解释什么是混叠问题，何时有害，如何处理。</p>
<h4 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXi <span class="title">mat</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mat.<span class="built_in">bottomRightCorner</span>(<span class="number">2</span>,<span class="number">2</span>) = mat.<span class="built_in">topLeftCorner</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the assignment:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mat:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">After the assignment: </span><br><span class="line">1 2 3</span><br><span class="line">4 1 2</span><br><span class="line">7 4 1</span><br></pre></td></tr></table></figure>
<p>可见，输出并不像我们所期望的一样将左上角的 $2\times2$ 子矩阵赋值给右下角的 $2\times2$ 子矩阵，这种情况正是由混叠问题引起的，赋值表达式的两端存在重叠的矩阵区域，即 $mat(1,1)$ 。之所以会造成这个问题，是因为Eigen中的赋值操作采用了<strong>延迟计算</strong>（也称惰性计算，Lazy Evaluation），即赋值运算并不会马上执行，而是在用到该变量时才进行计算，上述赋值运算等价于如下过程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">1</span>) = <span class="built_in">mat</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">2</span>) = <span class="built_in">mat</span>(<span class="number">0</span>,<span class="number">1</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">2</span>,<span class="number">1</span>) = <span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line"><span class="built_in">mat</span>(<span class="number">2</span>,<span class="number">2</span>) = <span class="built_in">mat</span>(<span class="number">1</span>,<span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p>所以，在为 <code>mat(2,2)</code> 赋值时，<code>mat(1,1)</code> 已经不再是旧的值，而已经被赋上了新的值。</p>
<p>尝试进行矩阵压缩的时候很容易出现混叠问题，例如 <code>vec = vec.head(n);</code> 或 <code>mat = mat.block(i,j,row,col);</code> 等。</p>
<p>通常情况下，混叠问题在编译过程中是不会被识别出来的，但运行时会以异常信息 (run-time assertion) 做出提示，可以使用 <code>EIGEN_NO_DEBUG</code> 退出debug模式关闭异常提示，但最好不要。</p>
<h4 id="如何解决混叠问题"><a href="#如何解决混叠问题" class="headerlink" title="如何解决混叠问题"></a>如何解决混叠问题</h4><p>显然，最简单的解决方法就是把右侧的计算结果赋给一个临时变量，计算结束后再将这个临时变量赋值给左侧的变量，Eigen中使用 <code>eval()</code> 函数实现。用 <code>eval()</code> 纠正上例中出现的问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXi <span class="title">mat</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">mat &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">mat.<span class="built_in">bottomRightCorner</span>(<span class="number">2</span>,<span class="number">2</span>) = mat.<span class="built_in">topLeftCorner</span>(<span class="number">2</span>,<span class="number">2</span>).<span class="built_in">eval</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the assignment:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mat:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br><span class="line">After the assignment: </span><br><span class="line">1 2 3</span><br><span class="line">4 1 2</span><br><span class="line">7 4 5</span><br></pre></td></tr></table></figure>
<p>又例如对矩阵作转置时，直接使用 <code>a = a.transpose();</code> 会导致混叠问题：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Matrix2i a; a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">a = a.<span class="built_in">transpose</span>(); <span class="comment">// !!! do NOT do this !!!</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Transposed a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Matrix a:</span><br><span class="line">1 2</span><br><span class="line">3 4</span><br><span class="line">Transposed a:</span><br><span class="line">1 2</span><br><span class="line">2 4</span><br></pre></td></tr></table></figure>
<p>与上面相同的解决方法，即使用 <code>a = a.transpose().eval()</code> 代替。此外，Eigen提供了一种专门针对这种情况的特殊函数 <code>transposeInPlace()</code> 以实现将当前矩阵替换为其转置矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">3</span>)</span></span>; a &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the initial matrix a:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">a.<span class="built_in">transposeInPlace</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;and after being transposed:\n&quot;</span> &lt;&lt; a &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Here is the initial matrix a:</span><br><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">and after being transposed:</span><br><span class="line">1 4</span><br><span class="line">2 5</span><br><span class="line">3 6</span><br></pre></td></tr></table></figure>
<p>类似的原地处理函数还有：</p>
<ul>
<li><code>MatrixBase::adjoint()</code> &lt;-&gt; <code>MatrixBase::adjointInPlace()</code></li>
<li><code>DenseBase::reverse()</code> &lt;-&gt; <code>DenseBase::reverseInPlace()</code></li>
<li><code>LDLT::solve()</code> &lt;-&gt; <code>LDLT::solveInPlace()</code></li>
<li><code>LLT::solve()</code> &lt;-&gt; <code>LLT::solveInPlace()</code></li>
<li><code>TriangularView::solve()</code> &lt;-&gt; <code>TriangularView::solveInPlace()</code></li>
<li><code>DenseBase::transpose()</code> &lt;-&gt; <code>DenseBase::transposeInPlace()</code></li>
</ul>
<p>针对矩阵/向量压缩处理（取几行几列/取前几个元素），例如 <code>vec = vec.head(n)</code> ，可以使用 <code>conservativeResize()</code> 实现原地处理。</p>
<h4 id="混叠问题与元素级操作"><a href="#混叠问题与元素级操作" class="headerlink" title="混叠问题与元素级操作"></a>混叠问题与元素级操作</h4><p>在元素级操作中，尽管赋值表达式两边也有可能出现同一个矩阵（例如矩阵加法，数组乘法，标量乘法等），但不会对结果产生影响，即元素级操作中的混叠是安全的，因此也就不需要 <code>eval()</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>; </span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,  <span class="number">4</span>, <span class="number">7</span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Here is the matrix mat:\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">mat = <span class="number">2</span> * mat;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After &#x27;mat = 2 * mat&#x27;, mat = \n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">mat = mat - MatrixXf::<span class="built_in">Identity</span>(<span class="number">2</span>,<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After the subtraction, it becomes\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"> </span><br><span class="line">ArrayXXf arr = mat;</span><br><span class="line">arr = arr.<span class="built_in">square</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;After squaring, it becomes\n&quot;</span> &lt;&lt; arr &lt;&lt; endl &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// Combining all operations in one statement:</span></span><br><span class="line">mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,  <span class="number">4</span>, <span class="number">7</span>;</span><br><span class="line">mat = (<span class="number">2</span> * mat - MatrixXf::<span class="built_in">Identity</span>(<span class="number">2</span>,<span class="number">2</span>)).<span class="built_in">array</span>().<span class="built_in">square</span>();</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Doing everything at once yields\n&quot;</span> &lt;&lt; mat &lt;&lt; endl &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">Here is the matrix mat:</span><br><span class="line">1 2</span><br><span class="line">4 7</span><br><span class="line"></span><br><span class="line">After <span class="string">&#x27;mat = 2 * mat&#x27;</span>, mat = </span><br><span class="line"> 2  4</span><br><span class="line"> 8 14</span><br><span class="line"></span><br><span class="line">After the subtraction, it becomes</span><br><span class="line"> 1  4</span><br><span class="line"> 8 13</span><br><span class="line"></span><br><span class="line">After squaring, it becomes</span><br><span class="line">  1  16</span><br><span class="line"> 64 169</span><br><span class="line"></span><br><span class="line">Doing everything at once yields</span><br><span class="line">  1  16</span><br><span class="line"> 64 169</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p><strong>总而言之，当表达式右侧的 <code>(i,j)</code> 元素仅仅依赖于表达式左侧对应的 <code>(i,j)</code> 元素时，赋值操作是安全的，也就不再需要多余的 <code>eval()</code> 操作。</strong></p>
<h4 id="混叠问题与矩阵乘法"><a href="#混叠问题与矩阵乘法" class="headerlink" title="混叠问题与矩阵乘法"></a>混叠问题与矩阵乘法</h4><p>在目标矩阵未调整大小的情况下，矩阵乘法是Eigen中唯一默认进行混叠处理的操作。换言之，若矩阵 <code>matA</code> 为平方型矩阵（<strong>行数 = 列数</strong>），则赋值语句 <code>matA = matA*matA</code> 是安全的。</p>
<p>除此之外的所有操作，Eigen都默认不存在由混叠导致的错误，要么是因为结果被赋值给了一个不同的矩阵，要么是因为当前进行的是元素级操作。</p>
<p>不过Eigen对矩阵乘法进行的这种处理是需要付出一定计算资源的代价的。在进行上述乘法的过程中，Eigen首先将乘积计算入一个临时矩阵，结束计算后再将这个临时矩阵赋值给 <code>matA</code> ，在当前情况下这是合理的。但相同的操作也会对 <code>matB = matA * matA</code> 进行，这就会导致一定程度上的计算资源浪费。在这种情况下，Eigen提供了 <code>noalias()</code> 函数进行直接赋值而不用经过中间的临时矩阵：<code>matB.noalias() = matA * matA</code> 。这种操作一定要<strong>慎用！！！</strong></p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>当表达式两端同时出现相同的矩阵/数组时会出现混叠</p>
<ul>
<li>元素级操作时无害，包括标量/数组乘法和矩阵/数组加法</li>
<li>两个行列相等的矩阵相乘，Eigen默认进行混叠处理；若明确不会出现混叠，使用 <code>noalias()</code> </li>
<li>其他情况下Eigen默认不进行混叠处理，因此容易在某些情况下产生错误答案。使用 <code>eval()</code> 或 <code>xxxInPlace()</code> 函数来避免此类情况</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%8F%98%E5%BD%A2%E4%B8%8E%E5%88%86%E7%89%87/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%8F%98%E5%BD%A2%E4%B8%8E%E5%88%86%E7%89%87/" class="post-title-link" itemprop="url">变形与切片</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-23 17:10:44" itemprop="dateCreated datePublished" datetime="2021-04-23T17:10:44+08:00">2021-04-23</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-05-11 16:00:58" itemprop="dateModified" datetime="2021-05-11T16:00:58+08:00">2021-05-11</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>Eigen 尚未提供显式方法实现变形与切片，但可以用Map类模拟实现</p>
<h4 id="变形"><a href="#变形" class="headerlink" title="变形"></a>变形</h4><p>变形指的是在保持原有矩阵系数不变的情况下，调整矩阵的行列大小，Map类提供了一种在原有存储的基础上创建不同矩阵视图的方法，需要注意的是，原矩阵中的数据存储顺序会影响数据在线性视图中的顺序：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">MatrixXf <span class="title">Ma</span><span class="params">(<span class="number">3</span>,<span class="number">3</span>)</span></span>;</span><br><span class="line">M1 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,</span><br><span class="line">	  <span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,</span><br><span class="line">	  <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">Map&lt;RowVectorXf&gt; <span class="title">v1</span><span class="params">(M1.data(), M1.size())</span></span>; <span class="comment">// M1.data()将按列优先取出数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v1:&quot;</span> &lt;&lt; endl &lt;&lt; v1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; <span class="title">M2</span><span class="params">(M1)</span></span>;</span><br><span class="line"><span class="function">Map&lt;RowVectorXf&gt; <span class="title">v2</span><span class="params">(M2.data(), M2.size())</span></span>; <span class="comment">// M2.data()将按行优先取出数据</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;v2:&quot;</span> &lt;&lt; endl &lt;&lt; v2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">v1:</span><br><span class="line">1 4 7 2 5 8 3 6 9</span><br><span class="line">v2:</span><br><span class="line">1 2 3 4 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<ul>
<li>例：2 $\times$ 6 矩阵转置为6 $\times$ 2：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; <span class="title">M1</span><span class="params">(<span class="number">2</span>,<span class="number">6</span>)</span></span>;</span><br><span class="line">M1 &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>,</span><br><span class="line">	  <span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>;</span><br><span class="line"><span class="function">Map&lt;MatrixXf&gt; <span class="title">M2</span><span class="params">(M1.data(), <span class="number">6</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;M2:&quot;</span> &lt;&lt; endl &lt;&lt; M2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">M2:</span><br><span class="line">1  7</span><br><span class="line">2  8</span><br><span class="line">3  9</span><br><span class="line">4 10</span><br><span class="line">5 11</span><br><span class="line">6 12</span><br></pre></td></tr></table></figure>
<p>注意到实现矩阵转置的时候，必须采用行优先保存，否则变形出来的矩阵就不是转置矩阵了！</p>
<h4 id="切片"><a href="#切片" class="headerlink" title="切片"></a>切片</h4><p>切片指的是取出矩阵中均匀间隔的行、列或元素</p>
<ul>
<li>例：间隔取出向量中的某些元素</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RowVectorXf v = RowVectorXf::<span class="built_in">LinSpaced</span>(<span class="number">20</span>,<span class="number">0</span>,<span class="number">19</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Input:&quot;</span> &lt;&lt; endl &lt;&lt; v &lt;&lt; endl;</span><br><span class="line">Map&lt;RowVectorXf,<span class="number">0</span>,InnerStride&lt;<span class="number">2</span>&gt; &gt; <span class="built_in">v2</span>(v.<span class="built_in">data</span>(), v.<span class="built_in">size</span>()/<span class="number">2</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Even:&quot;</span> &lt;&lt; v2 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Input:</span><br><span class="line"> 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19</span><br><span class="line">Even: 0  2  4  6  8 10 12 14 16 18</span><br></pre></td></tr></table></figure>
<ul>
<li>例：根据具体的存储顺序，使用足够的步幅 <code>stride</code> 依次从三列中取出一列</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">MatrixXf M1 = MatrixXf::<span class="built_in">Random</span>(<span class="number">3</span>, <span class="number">8</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Column Major Input:\n&quot;</span></span><br><span class="line">     &lt;&lt; M1 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Map&lt;MatrixXf, <span class="number">0</span>, OuterStride&lt;&gt;&gt; <span class="built_in">M2</span>(</span><br><span class="line">    M1.<span class="built_in">data</span>(), M1.<span class="built_in">rows</span>(), (M1.<span class="built_in">cols</span>() + <span class="number">2</span>) / <span class="number">3</span>,</span><br><span class="line">    OuterStride&lt;&gt;(M1.<span class="built_in">outerStride</span>() * <span class="number">3</span>));</span><br><span class="line"><span class="comment">// 第二个参数 MapOptions=0 即使用默认值Unaligned</span></span><br><span class="line"><span class="comment">// 第三个参数 OuterStride&lt;&gt;说明初始化时只需声明外步幅的大小</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对列优先矩阵取出每3列中的第1列:\n&quot;</span></span><br><span class="line">     &lt;&lt; M2 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="keyword">float</span>, Dynamic, Dynamic, RowMajor&gt; RowMajorMatrixXf;</span><br><span class="line"><span class="function">RowMajorMatrixXf <span class="title">M3</span><span class="params">(M1)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row Major Input:\n&quot;</span></span><br><span class="line">     &lt;&lt; M3 &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">Map&lt;RowMajorMatrixXf, <span class="number">0</span>, Stride&lt;Dynamic, <span class="number">3</span>&gt;&gt; <span class="built_in">M4</span>(</span><br><span class="line">    M3.<span class="built_in">data</span>(), M3.<span class="built_in">rows</span>(), (M3.<span class="built_in">cols</span>() + <span class="number">2</span>) / <span class="number">3</span>,</span><br><span class="line">    Stride&lt;Dynamic, <span class="number">3</span>&gt;(M3.<span class="built_in">outerStride</span>(), <span class="number">3</span>)); <span class="comment">// 意味着行间步幅1，列间步幅3</span></span><br><span class="line"><span class="comment">// 第三个参数 Stride&lt;OuterStride&lt;&gt;, InnerStride&lt;&gt;&gt; 指定外步幅和内步幅</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;对行优先矩阵取出每3列中的第1列:\n&quot;</span></span><br><span class="line">     &lt;&lt; M4 &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">Column Major Input:</span><br><span class="line">  0.680375    0.59688  -0.329554    0.10794  -0.270431    0.83239  -0.716795  -0.514226</span><br><span class="line"> -0.211234   0.823295   0.536459 -0.0452059  0.0268018   0.271423   0.213938  -0.725537</span><br><span class="line">  0.566198  -0.604897  -0.444451   0.257742   0.904459   0.434594  -0.967399   0.608353</span><br><span class="line">对列优先矩阵取出每3列中的第1列:</span><br><span class="line">  0.680375    0.10794  -0.716795</span><br><span class="line"> -0.211234 -0.0452059   0.213938</span><br><span class="line">  0.566198   0.257742  -0.967399</span><br><span class="line">Row Major Input:</span><br><span class="line">  0.680375    0.59688  -0.329554    0.10794  -0.270431    0.83239  -0.716795  -0.514226</span><br><span class="line"> -0.211234   0.823295   0.536459 -0.0452059  0.0268018   0.271423   0.213938  -0.725537</span><br><span class="line">  0.566198  -0.604897  -0.444451   0.257742   0.904459   0.434594  -0.967399   0.608353</span><br><span class="line">对行优先矩阵取出每3列中的第1列:</span><br><span class="line">  0.680375    0.10794  -0.716795</span><br><span class="line"> -0.211234 -0.0452059   0.213938</span><br><span class="line">  0.566198   0.257742  -0.967399</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/Map%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%8EC-C++%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/Map%E7%B1%BB%E5%AE%9E%E7%8E%B0%E4%B8%8EC-C++%E6%95%B0%E7%BB%84%E7%9A%84%E8%BD%AC%E6%8D%A2/" class="post-title-link" itemprop="url">Map类实现与C/C++数组的转换</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>
              

              <time title="创建时间：2021-04-23 15:24:43 / 修改时间：17:05:18" itemprop="dateCreated datePublished" datetime="2021-04-23T15:24:43+08:00">2021-04-23</time>
            </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍如何使用 <code>Map</code> 类通过不复制数据的方法将原始 C/C++ 数组转换成矩阵或向量</p>
<h3 id="Map类模板参数与构造函数"><a href="#Map类模板参数与构造函数" class="headerlink" title="Map类模板参数与构造函数"></a>Map类模板参数与构造函数</h3><p>Map类模板参数如下：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Map&lt;<span class="keyword">typename</span> MatrixType, <span class="keyword">int</span> MapOptions = Unaligned, <span class="keyword">typename</span> StrideType&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>MatrixType</code> : <code>required</code> ，声明是哪种类型的矩阵或向量</p>
</li>
<li><p><code>MapOptions</code> : <code>optional</code> ，声明指针是对齐的还是未对齐的</p>
</li>
<li><p><code>StrideType</code> : <code>optional</code> ，使用<a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/classEigen_1_1Stride.html"> <code>Stride</code> 类</a>为内存中的数组自定义布局</p>
<p><code>Stride</code> 类有两个模板参数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Stride&lt;OuterStride, InnerStride&gt;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>OuterStride</code> : 指的是 列优先矩阵的两个连续列 或 行优先矩阵的两个连续行 之间的指针增量</li>
<li><code>InnerStride</code> : 指的是 列优先矩阵的某一列内两个连续行 或 行优先矩阵的某一列内两个连续列 之间的指针增量</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">8</span>; ++i) array[i] = i;</span><br><span class="line"><span class="comment">// 默认列优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Column-major:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt; &gt;(array) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过定义矩阵类型实现行优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>,RowMajor&gt; &gt;(array) &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 通过Stride参数实现行优先</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Row-major using stride:\n&quot;</span> </span><br><span class="line">     &lt;&lt; Map&lt;Matrix&lt;<span class="keyword">int</span>,<span class="number">2</span>,<span class="number">4</span>&gt;, Unaligned, Stride&lt;<span class="number">1</span>,<span class="number">4</span>&gt; &gt;(array) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Column-major:</span><br><span class="line">0 2 4 6</span><br><span class="line">1 3 5 7</span><br><span class="line">Row-major:</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br><span class="line">Row-major using stride:</span><br><span class="line">0 1 2 3</span><br><span class="line">4 5 6 7</span><br></pre></td></tr></table></figure>
<p><code>Stride</code> 类还能更灵活：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> array[<span class="number">24</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">24</span>; ++i) array[i] = i;</span><br><span class="line">cout &lt;&lt; Map&lt;MatrixXi, <span class="number">0</span>, Stride&lt;Dynamic,<span class="number">2</span>&gt; &gt;</span><br><span class="line">        (array, <span class="number">3</span>, <span class="number">3</span>, Stride&lt;Dynamic,<span class="number">2</span>&gt;(<span class="number">8</span>, <span class="number">2</span>))</span><br><span class="line">     &lt;&lt; endl;</span><br><span class="line"><span class="comment">// 列间隔8，行间隔2</span></span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">0  8 16</span><br><span class="line">2 10 18</span><br><span class="line">4 12 20</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>在构造一个Map类型对象的时候，还需要另外两个信息：指向数组内存空间的指针；目标矩阵/向量的大小。当矩阵/变量类型为固定大小的类型时，第二个信息可以省略。</p>
<ul>
<li><p>构造一个Map类型的对象用来转换动态大小的 <code>float</code> 矩阵：其中 <code>pf</code> 是一个 <code>float*</code> 类型的指针，指向数组内存空间，<code>rows</code> 和 <code>cols</code> 则定义了目标矩阵的维度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;MatrixXf&gt; <span class="title">mf</span><span class="params">(pf, rows, cols)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
<li><p>构造一个Map类型的对象用来转换固定大小的 <code>int</code> 只读向量：其中 <code>pi</code> 是一个 <code>int*</code> 类型的指针，因为 <code>Vector4i</code> 已经说明了向量维度，所以不再需要向构造函数传入向量的维度信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;<span class="keyword">const</span> Vector4i&gt; <span class="title">mi</span><span class="params">(pi)</span></span>;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>需要注意的是，Map类并没有默认构造函数，在构造对象的时候，必须告诉构造函数所要转化的数组的地址指针。</p>
<h3 id="Map类型对象的使用"><a href="#Map类型对象的使用" class="headerlink" title="Map类型对象的使用"></a>Map类型对象的使用</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> Matrix&lt;<span class="keyword">float</span>, <span class="number">1</span>, Dynamic&gt; MatrixType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;MatrixType&gt; MapType;</span><br><span class="line"><span class="keyword">typedef</span> Map&lt;<span class="keyword">const</span> MatrixType&gt; MapTypeConst; <span class="comment">// a read-only map</span></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> n_dims = <span class="number">5</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">MatrixType <span class="title">m1</span><span class="params">(n_dims)</span>, <span class="title">m2</span><span class="params">(n_dims)</span></span>;</span><br><span class="line">m1.<span class="built_in">setRandom</span>();</span><br><span class="line">m2.<span class="built_in">setRandom</span>();</span><br><span class="line"><span class="keyword">float</span> *p = &amp;<span class="built_in">m2</span>(<span class="number">0</span>); <span class="comment">// 拿到矩阵m2的地址</span></span><br><span class="line"><span class="function">MapType <span class="title">m2map</span><span class="params">(p,m2.size())</span></span>; <span class="comment">// 矩阵m2map和矩阵m2共享内存空间（地址相同）</span></span><br><span class="line"><span class="function">MapTypeConst <span class="title">m2mapconst</span><span class="params">(p, m2.size())</span></span>; <span class="comment">// 通过矩阵m2mapconst只能实现对m2的访问，而不能修改</span></span><br><span class="line"></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m1: &quot;</span> &lt;&lt; m1 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance: &quot;</span> &lt;&lt; (m1-m2).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Squared euclidean distance, using map: &quot;</span> </span><br><span class="line">     &lt;&lt; (m1-m2map).<span class="built_in">squaredNorm</span>() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line"><span class="built_in">m2map</span>(<span class="number">3</span>) = <span class="number">7</span>;   <span class="comment">// 这一步会同时改变m2和m2mapconst的值，因为这三者共享内存空间</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Updated m2: &quot;</span> &lt;&lt; m2 &lt;&lt; endl;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;m2 coefficient 2, constant accessor: &quot;</span> &lt;&lt; <span class="built_in">m2mapconst</span>(<span class="number">3</span>) &lt;&lt; endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">m1:  0.680375 -0.211234  0.566198   0.59688  0.823295</span><br><span class="line">m2: -0.604897 -0.329554  0.536459 -0.444451   0.10794</span><br><span class="line">Squared euclidean distance: 3.26291</span><br><span class="line">Squared euclidean distance, using map: 3.26291</span><br><span class="line">Updated m2: -0.604897 -0.329554  0.536459         7   0.10794</span><br><span class="line">m2 coefficient 2, constant accessor: 7</span><br></pre></td></tr></table></figure>
<p>虽然Eigen的所有函数都会像接受其他Eigen类型一样接受Map对象，但在实现自己的函数过程中，从Map对象到其对应的Dense类对象的转换并不会自动完成。具体见 <a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/TopicFunctionTakingEigenTypes.html">以Eigen类型为参数编写函数</a> </p>
<h3 id="修改映射数组"><a href="#修改映射数组" class="headerlink" title="修改映射数组"></a>修改映射数组</h3><p>可以使用C++的 <code>placement new</code> 语法实现在生命Map对象后修改其数组。简而言之，<code>placement new</code> 语法实现的是从给定指针所指向的地址开始创建一个新的对象，一般来说该指针指向的是一片提前申请好的内存，所以也不会进行内存分配。例如：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> data[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function">Map&lt;RowVectorXi&gt; <span class="title">v</span><span class="params">(data,<span class="number">4</span>)</span></span>;</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;The mapped vector v is: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line"><span class="keyword">new</span> (&amp;v) Map&lt;RowVectorXi&gt;(data+<span class="number">4</span>,<span class="number">5</span>);</span><br><span class="line">cout &lt;&lt; <span class="string">&quot;Now v is: &quot;</span> &lt;&lt; v &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">The mapped vector v is: 1 2 3 4</span><br><span class="line">Now v is: 5 6 7 8 9</span><br></pre></td></tr></table></figure>
<p>用这种方法可以在不知道映射数组在内存中位置的情况下构造一个Map对象：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Map&lt;Matrix3f&gt; <span class="title">A</span><span class="params">(<span class="literal">NULL</span>)</span></span>;  <span class="comment">// don&#x27;t try to use this matrix yet!</span></span><br><span class="line"><span class="function">VectorXf <span class="title">b</span><span class="params">(n_matrices)</span></span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n_matrices; i++)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">new</span> (&amp;A) Map&lt;Matrix3f&gt;(<span class="built_in">get_matrix_pointer</span>(i));</span><br><span class="line">    <span class="built_in">b</span>(i) = A.<span class="built_in">trace</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/experiment/%E5%A6%82%E4%BD%95%E5%B0%86Labelme%E6%A0%87%E6%B3%A8%E5%9B%BE%E5%83%8F%E8%BD%AC%E4%B8%BACULane%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/experiment/%E5%A6%82%E4%BD%95%E5%B0%86Labelme%E6%A0%87%E6%B3%A8%E5%9B%BE%E5%83%8F%E8%BD%AC%E4%B8%BACULane%E6%95%B0%E6%8D%AE%E9%9B%86%E6%A0%BC%E5%BC%8F/" class="post-title-link" itemprop="url">如何将Labelme标注图像转为CULane数据集格式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 20:31:34" itemprop="dateCreated datePublished" datetime="2021-04-22T20:31:34+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 14:49:55" itemprop="dateModified" datetime="2021-04-23T14:49:55+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/experiment/" itemprop="url" rel="index"><span itemprop="name">experiment</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>毕设做铁路轨道检测，发现Lane Detection的大部分开源代码都是跑的公用数据集CULane（或Tusimple），而我们自己采集的数据用labelme标注完以后不是CULane的标准格式。为了能直接用公开代码训练我们自己的数据集，需要先把labelme标注的json数据转化成CULane标准格式。</p>
<p>项目地址：[labelme_to_culane] </p>
<h3 id="CULane数据集"><a href="#CULane数据集" class="headerlink" title="CULane数据集"></a>CULane数据集</h3><p>根据<a target="_blank" rel="noopener" href="https://xingangpan.github.io/projects/CULane.html">官网</a>的介绍，CULane数据集文件包括：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">- driver_23_30frame</span><br><span class="line">- driver_161_90frame</span><br><span class="line">- driver_182_30frame</span><br><span class="line">- driver_37_30frame</span><br><span class="line">- driver_100_30frame</span><br><span class="line">- driver_193_90frame</span><br><span class="line">- laneseg_label_w16</span><br><span class="line">- list</span><br></pre></td></tr></table></figure>
<ul>
<li><p>三个训练集&amp;验证集ground truth图像与标注：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- driver_23_30frame</span><br><span class="line">- driver_161_90frame</span><br><span class="line">- driver_182_30frame</span><br></pre></td></tr></table></figure>
<p>每个文件夹下都包含若干视频中抽帧形成的子文件夹，每个子文件夹又包含若干图像数据文件（eg. xxxx.jpg）和一个对应的标注文件（xxxx.lines.txt），以182_30文件为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- driver_182_30frame</span><br><span class="line">  - 05312327_0001.MP4</span><br><span class="line">    |- 00000.jpg</span><br><span class="line">    |- 00000.lines.txt</span><br><span class="line">    |- 00030.jpg</span><br><span class="line">    |- 00030.lines.txt</span><br><span class="line">    |- 00060.jpg</span><br><span class="line">    |- 00060.lines.txt</span><br><span class="line">    ...</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure>
<p>标注文件中每一行都给出了车道线上关键点的对应（x，y）坐标，以 <code>05130.lines.txt</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">104.092 590 123.101 580 144.826 570 165.645 560 187.369 550 208.189 540 229.913 530 250.733 520 272.457 510 293.277 500 315.001 490 335.82 480 357.545 470 379.269 460 399.746 450 421.471 440 442.29 430 464.015 420 485.373 410 506.192 400 527.551 390 549.275 380 570.095 370 591.452 360 613.176 350 633.996 340 655.72 330 677.001 320 698.726 310 719.545 300 740.828 290 762.552 280 783.371 270 </span><br><span class="line">661.843 590 665.482 580 669.121 570 673.124 560 677.128 550 681.131 540 684.77 530 688.773 520 692.775 510 696.778 500 700.417 490 704.419 480 708.422 470 712.06 460 716.093 450 720.096 440 724.099 430 727.918 420 731.922 410 735.562 400 739.746 390 743.385 380 747.387 370 751.206 360 755.208 350 759.211 340 763.215 330 766.854 320 770.858 310 774.862 300 778.5 290 782.503 280 786.505 270 </span><br><span class="line">1457.13 590 1438.25 580 1418.46 570 1397.78 560 1377.09 550 1356.41 540 1335.96 530 1315.27 520 1294.59 510 1273.91 500 1253.22 490 1232.77 480 1212.09 470 1192.3 460 1171.62 450 1150.94 440 1130.47 430 1109.79 420 1089.11 410 1068.42 400 1047.74 390 1027.84 380 1007.16 370 986.473 360 965.79 350 945.106 340 924.422 330 903.617 320 883.833 310 863.149 300 842.466 290 821.782 280 801.099 270 </span><br><span class="line">1676.79 450 1632.17 440 1587.27 430 1542.37 420 1497.07 410 1452.17 400 1406.89 390 1361.98 380 1317.08 370 1272.76 360 1227.86 350 1182.96 340 1137.76 330 1092.86 320 1047.96 310 1003.06 300 957.841 290 912.94 280 868.04 270 </span><br></pre></td></tr></table></figure>
<p>其中，关键点选取的y坐标，是固定的，称其为<strong>行锚点</strong> ，默认图像大小为288 * 800：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">culane_row_anchor = [121, 131, 141, 150, 160, 170, 180, 189, 199, 209, 219, 228, 238, 248, 258, 267, 277, 287]</span><br></pre></td></tr></table></figure>
</li>
<li><p>测试集ground truth图像及标注：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">- driver_37_30frame</span><br><span class="line">- driver_100_30frame</span><br><span class="line">- driver_193_90frame</span><br></pre></td></tr></table></figure>
<p>格式与训练集/验证集相同</p>
</li>
<li><p>训练集/验证集车道线分割label图像：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- laneseg_label_w16</span><br></pre></td></tr></table></figure>
<p>该文件夹下为训练集/验证集中所有ground truth图像所对应的逐像素label图，即每个像素点的值表示它所在的车道线id，0表示背景。</p>
</li>
<li><p>训练集/验证集/测试集列表</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- </span><br><span class="line">  - list</span><br><span class="line">    |- test_split</span><br><span class="line">       |- test0_normal.txt</span><br><span class="line">       |- test1_crowd.txt</span><br><span class="line">       |- test2_hlight.txt</span><br><span class="line">       |- test3_shadow.txt</span><br><span class="line">       |- test4_noline.txt</span><br><span class="line">       |- test5_arrow.txt</span><br><span class="line">       |- test6_curve.txt</span><br><span class="line">       |- test7_cross.txt</span><br><span class="line">       |- test8_night.txt</span><br><span class="line">    |- test.txt</span><br><span class="line">    |- train.txt</span><br><span class="line">    |- train_gt.txt</span><br><span class="line">    |- val.txt</span><br><span class="line">    |- val_gt.txt</span><br></pre></td></tr></table></figure>
<ul>
<li><p><code>trian.txt</code> <code>val.txt</code> <code>test.txt</code> 都是对应训练集/验证集/测试集图像的相对路径，以 <code>test.txt</code> 为例：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/driver_100_30frame/05251517_0433.MP4/00000.jpg</span><br><span class="line">/driver_100_30frame/05251517_0433.MP4/00030.jpg</span><br><span class="line">/driver_100_30frame/05251517_0433.MP4/00060.jpg</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
</li>
<li><p><code>test_split</code> 文件夹下的文件是将测试集 <code>test.txt</code> 分为不同的环境后重组，本质也是图像的相对路径</p>
</li>
<li><p><code>train_gt.txt</code> 和 <code>val_gt.txt</code> 中每行的格式为：</p>
<p>gt图像相对路径 逐像素label图像相对路径 四个0/1数字表示\&lt;左2>&lt;左1>&lt;右1>&lt;右2>四个车道是否存在</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/driver_23_30frame/05171102_0766.MP4/00020.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00020.png 1 1 1 0</span><br><span class="line">/driver_23_30frame/05171102_0766.MP4/00050.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00050.png 1 1 1 0</span><br><span class="line">/driver_23_30frame/05171102_0766.MP4/00080.jpg /laneseg_label_w16/driver_23_30frame/05171102_0766.MP4/00080.png 1 1 1 0</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<h3 id="从json标注文件到label-png"><a href="#从json标注文件到label-png" class="headerlink" title="从json标注文件到label.png"></a>从json标注文件到label.png</h3><p>labelme提供了将json文件转为label.png的方法：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">labelme_json_to_dataset [-h] [-o output_file] json_file.json</span><br></pre></td></tr></table></figure>
<p>此方法实现对一个json文件的转换，将生成以下文件：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">- output_file</span><br><span class="line">  |- json_file_json</span><br><span class="line">     |- img.png</span><br><span class="line">     |- label.png</span><br><span class="line">     |- label_names.txt</span><br><span class="line">     |- lable_viz.png</span><br></pre></td></tr></table></figure>
<p>实现json文件批量转化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> os.path <span class="keyword">as</span> osp</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name <span class="keyword">in</span> os.listdir(json_files_path):</span><br><span class="line">    json_data = osp.join(json_files_path, name)</span><br><span class="line">    os.system(<span class="string">&quot;labelme_json_to_dataset json_data -o &quot;</span> + output_path)</span><br></pre></td></tr></table></figure>
<p>如果在标注的时候不是用的纯数字，labelme在进行转换的时候会首先对标注进行字符串排序，排序后的结果在 <code>label_names.txt</code> 中；<code>label.png</code> 虽然看上去是彩色图，但用 <code>PIL.Image</code> 读入后会发现，这其实是个逐像素分类的图，像素值由 <code>label_names.txt</code> 中的标注顺序生成（下标/像素从0开始，其中0表示的是背景，即 <code>label_names.txt</code> 中的第一个默认分类 <code>_background_</code> ）。存在的像素值对应 <code>*_gt.txt</code> 中的值为1，否则为0</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line"></span><br><span class="line">label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">label_data = ny.asarray(label).copy()</span><br><span class="line">label.save(target_path)</span><br></pre></td></tr></table></figure>
<p>这样就得到了我们需要的 <code>xxxx_label.png</code> 文件</p>
<h3 id="从label-png到-xxxx-lines-txt-和-gt-txt-文件"><a href="#从label-png到-xxxx-lines-txt-和-gt-txt-文件" class="headerlink" title="从label.png到 xxxx.lines.txt 和 *_gt.txt 文件"></a>从label.png到 xxxx.lines.txt 和 *_gt.txt 文件</h3><ul>
<li>根据 <code>label.png</code> 和 <code>culane_row_anchor</code> 获取轨道线上关键点的坐标生成 <code>xxxx.lines.txt</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># image = Image.open(image_path)</span></span><br><span class="line">label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">w, h = label.size</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将行采样点按输入图像高度放缩</span></span><br><span class="line"><span class="keyword">if</span> h != <span class="number">288</span>:</span><br><span class="line">    scale_f = <span class="keyword">lambda</span> x : <span class="built_in">int</span>((x * <span class="number">1.0</span>/<span class="number">288</span>) * h)</span><br><span class="line">    sample_tmp = <span class="built_in">list</span>(<span class="built_in">map</span>(scale_f,culane_row_anchor)) </span><br><span class="line">    <span class="comment"># 根据提供的函数对指定序列做映射</span></span><br><span class="line"></span><br><span class="line">lines = <span class="string">&quot;&quot;</span> </span><br><span class="line"><span class="keyword">for</span> i,r <span class="keyword">in</span> <span class="built_in">enumerate</span>(sample_tmp):</span><br><span class="line">    label_r = np.asarray(label)[<span class="built_in">int</span>(<span class="built_in">round</span>(r))] </span><br><span class="line">    <span class="comment"># 取出label图像中行坐标为int(round(r))的一行        </span></span><br><span class="line">    <span class="keyword">for</span> lane_idx <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        line = <span class="string">&quot;&quot;</span></span><br><span class="line">        pos = np.where(label_r == lane_idx)[<span class="number">0</span>]</span><br><span class="line">        <span class="keyword">if</span> <span class="built_in">len</span>(pos) == <span class="number">0</span>:            </span><br><span class="line">            <span class="keyword">continue</span>        </span><br><span class="line">        pos = np.mean(pos)        </span><br><span class="line">        line = line + <span class="built_in">str</span>(pos) + <span class="string">&quot; &quot;</span> + <span class="built_in">str</span>(r) + <span class="string">&quot; &quot;</span></span><br><span class="line">        <span class="comment"># print(line)</span></span><br><span class="line">        <span class="comment"># cv2.circle(image, (int(round(pos)), int(round(r))), 1, (0,0,255),2)       </span></span><br><span class="line">    lines = lines + line + <span class="string">&quot;\n&quot;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(lines_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(lines)</span><br></pre></td></tr></table></figure>
<ul>
<li>根据 <code>label.png</code> 生成 <code>*_gt.txt</code> </li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">lines = <span class="string">&quot;&quot;</span></span><br><span class="line"><span class="keyword">for</span> label_path <span class="keyword">in</span> os.listdir(label_file_path):</span><br><span class="line">    label = Image.<span class="built_in">open</span>(label_path)</span><br><span class="line">    label_data = np.asarray(label).copy()</span><br><span class="line">    np.unique(label_data)</span><br><span class="line">    line = gt_image_path + <span class="string">&#x27; &#x27;</span> + label_path</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">1</span>, <span class="number">5</span>):</span><br><span class="line">        <span class="keyword">if</span> i <span class="keyword">in</span> label_data:</span><br><span class="line">            line = line + <span class="string">&#x27; 1&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            line = line + <span class="string">&#x27; 0&#x27;</span></span><br><span class="line">    lines = lines + line + <span class="string">&#x27;\n&#x27;</span></span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(gt_file_path, <span class="string">&#x27;w&#x27;</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(lines)</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E5%BD%92%E7%BA%A6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E5%BD%92%E7%BA%A6%E3%80%81%E8%BF%AD%E4%BB%A3%E5%99%A8%E5%92%8C%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">归约、迭代器和广播机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 11:51:55" itemprop="dateCreated datePublished" datetime="2021-04-22T11:51:55+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:38:02" itemprop="dateModified" datetime="2021-04-23T15:38:02+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍Eigen中的归约( <code>Reductions</code> )，迭代器( <code>Visitors</code> ) 和广播( <code>Broadcasting</code> )机制，以及它们是如何应用与矩阵和数组的。</p>
<h3 id="归约"><a href="#归约" class="headerlink" title="归约"></a>归约</h3><p>归约指的是一类以矩阵或数组作为输入，返回一个标量值的函数。</p>
<h4 id="常用归约函数"><a href="#常用归约函数" class="headerlink" title="常用归约函数"></a>常用归约函数</h4><p><code>.sum()</code> <code>.prod()</code> <code>.mean()</code> <code>.minCoeff()</code> <code>.maxCoeff()</code> <code>.trace()</code></p>
<h4 id="范数计算"><a href="#范数计算" class="headerlink" title="范数计算"></a>范数计算</h4><ul>
<li><code>.norm()</code> : L-2 范数（所有系数平方和开根号）</li>
<li><code>.squaredNorm()</code> : L-2 范数的平方（所有系数平方和）</li>
<li><code>.lpNorm&lt;p&gt;()</code> : P范数（所有系数绝对值的p次幂之和的p次根），当 <code>p=Infinity</code> 时表示所有系数绝对值的最大值</li>
</ul>
<h4 id="逻辑归约函数"><a href="#逻辑归约函数" class="headerlink" title="逻辑归约函数"></a>逻辑归约函数</h4><ul>
<li><code>.all()</code> : Matrix 或 Array 的所有系数均为 true 时返回 true</li>
<li><code>.any()</code> : Matrix 或 Array 存在某个系数为 true 时返回 true</li>
<li><code>.count()</code> : 返回 Matrix 或 Array 中为 true 的系数总个数</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ArrayXXf <span class="title">a</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>; </span><br><span class="line">  	a &lt;&lt; <span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>,<span class="number">4</span>; </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 0).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">0</span>).<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).all()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">all</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).any()   = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">any</span>() &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;(a &gt; 2).count() = &quot;</span> &lt;&lt; (a &gt; <span class="number">2</span>).<span class="built_in">count</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">(a &gt; 0).all()   = 1</span><br><span class="line">(a &gt; 0).any()   = 1</span><br><span class="line">(a &gt; 0).count() = 4</span><br><span class="line"></span><br><span class="line">(a &gt; 2).all()   = 0</span><br><span class="line">(a &gt; 2).any()   = 1</span><br><span class="line">(a &gt; 2).count() = 2</span><br></pre></td></tr></table></figure>
<h4 id="部分归约"><a href="#部分归约" class="headerlink" title="部分归约"></a>部分归约</h4><p>部分归约是可以对矩阵或数组按列或行进行操作的归约，对每个列或行应用归约运算，然后返回具有相应值的列或行向量。部分归约由函数 <code>.colwise()</code> 和 <code>rowwise()</code> 实现：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Column&#x27;s maximum: &quot;</span> &lt;&lt; endl</span><br><span class="line">   		 &lt;&lt; mat.<span class="built_in">colwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;Row&#x27;s maximum: &quot;</span> &lt;&lt; endl</span><br><span class="line">   		 &lt;&lt; mat.<span class="built_in">rowwise</span>().<span class="built_in">maxCoeff</span>() &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Column<span class="string">&#x27;s maximum: </span></span><br><span class="line"><span class="string">3 2 7 9</span></span><br><span class="line"><span class="string">Row&#x27;</span>s maximum: </span><br><span class="line">9</span><br><span class="line">7</span><br></pre></td></tr></table></figure>
<p>显然：<strong>列操作返回行向量，行操作返回列向量</strong> </p>
<h4 id="将部分归约与其他操作结合"><a href="#将部分归约与其他操作结合" class="headerlink" title="将部分归约与其他操作结合"></a>将部分归约与其他操作结合</h4><p>例：寻找系数和最大的列</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">  </span><br><span class="line">  	MatrixXf::Index   maxIndex;</span><br><span class="line">  	<span class="keyword">float</span> maxNorm = mat.<span class="built_in">colwise</span>().<span class="built_in">sum</span>().<span class="built_in">maxCoeff</span>(&amp;maxIndex);</span><br><span class="line">  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Maximum sum at position &quot;</span> &lt;&lt; maxIndex &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;The corresponding vector is: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat.<span class="built_in">col</span>( maxIndex ) &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;And its sum is is: &quot;</span> &lt;&lt; maxNorm &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Maximum sum at position 2</span><br><span class="line">The corresponding vector is: </span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">And its sum is is: 13</span><br></pre></td></tr></table></figure>
<h3 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h3><p>最常用的就是利用visitor机制获取矩阵/数组中最大值/最小值的位置，交给一个visitor的参数是指向存储行列位置变量的指针，变量类型为 <code>Index</code> ：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line">  	m &lt;&lt; <span class="number">1</span>, <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line"> </span><br><span class="line">  	<span class="comment">//get location of maximum</span></span><br><span class="line">  	MatrixXf::Index maxRow, maxCol;</span><br><span class="line">  	<span class="keyword">float</span> max = m.<span class="built_in">maxCoeff</span>(&amp;maxRow, &amp;maxCol);</span><br><span class="line"> </span><br><span class="line"> 	<span class="comment">//get location of minimum</span></span><br><span class="line">  	MatrixXf::Index minRow, minCol;</span><br><span class="line">  	<span class="keyword">float</span> min = m.<span class="built_in">minCoeff</span>(&amp;minRow, &amp;minCol);</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Max: &quot;</span> &lt;&lt; max &lt;&lt;  <span class="string">&quot;, at: &quot;</span> </span><br><span class="line">         &lt;&lt; maxRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; maxCol &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Min: &quot;</span> &lt;&lt; min &lt;&lt; <span class="string">&quot;, at: &quot;</span> </span><br><span class="line">         &lt;&lt; minRow &lt;&lt; <span class="string">&quot;,&quot;</span> &lt;&lt; minCol &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Max: 4, at: 1,1</span><br><span class="line">Min: 1, at: 0,0</span><br></pre></td></tr></table></figure>
<h3 id="广播"><a href="#广播" class="headerlink" title="广播"></a>广播</h3><p>广播机制类似于部分规约，区别在于广播构造了一个表达式，其中向量被解释成了一个矩阵，这个矩阵由向量在行/列方向上复制自身形成。</p>
<h4 id="加减（-、-、-、-）"><a href="#加减（-、-、-、-）" class="headerlink" title="加减（+、-、+=、-=）"></a>加减（+、-、+=、-=）</h4><p><strong>只能用于Vector类型的对象！！！</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">mat</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	<span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  	mat &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">           <span class="number">3</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">2</span>;   </span><br><span class="line">  	v &lt;&lt; <span class="number">0</span>,</span><br><span class="line">         <span class="number">1</span>;</span><br><span class="line">       </span><br><span class="line">  	<span class="comment">//add v to each column of m</span></span><br><span class="line">  	mat.<span class="built_in">colwise</span>() += v;</span><br><span class="line">  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Broadcasting result: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">    </span><br><span class="line">    <span class="function">Eigen::VectorXf <span class="title">w</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">    w &lt;&lt; <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>;</span><br><span class="line">       </span><br><span class="line">  	<span class="comment">//add w to each row of m</span></span><br><span class="line">  	mat.<span class="built_in">rowwise</span>() += v.<span class="built_in">transpose</span>();</span><br><span class="line">	  </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Broadcasting result: &quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Broadcasting result: </span><br><span class="line">1 2 6 9</span><br><span class="line">4 2 8 3</span><br><span class="line">Broadcasting result: </span><br><span class="line">1 3  8 12</span><br><span class="line">4 3 10  6</span><br></pre></td></tr></table></figure>
<p>在执行 <code>mat.colwise() += v</code> 时，相当于进行了两步操作，首先将向量 <code>v</code> 在行方向上复制了4次形成了一个新的4x2的矩阵，再将这个矩阵和矩阵 <code>mat</code> 进行加法操作：</p>
<script type="math/tex; mode=display">
\begin{bmatrix}
1 & 2 & 6 & 9 \\
3 & 1 & 7 & 2 
\end{bmatrix} + 
\begin{bmatrix}
0 & 0 & 0 & 0 \\
1 & 1 & 1 & 1 
\end{bmatrix} = 
\begin{bmatrix}
1 & 2 & 6 & 9 \\
4 & 2 & 8 & 3 
\end{bmatrix}</script><p>只有向量才能进行按行列加减，不能是矩阵，否则会报编译错误；</p>
<p>Array类同理，只能对 <code>ArrayXf</code> 执行这种操作</p>
<h4 id="乘除（、-、-、-）"><a href="#乘除（、-、-、-）" class="headerlink" title="乘除（、/、\=、/=）"></a>乘除（<em>、/、\</em>=、/=）</h4><p>按行/按列执行系数级乘法除法运算。</p>
<p><strong>只能用于 Array 类型的对象！！！</strong></p>
<p>如果想让矩阵第 <code>i</code> 列乘上向量的第 <code>i</code> 个系数，应该写成 <code>mat = mat * v.asDiagonal()</code> </p>
<h4 id="将广播与其他操作结合"><a href="#将广播与其他操作结合" class="headerlink" title="将广播与其他操作结合"></a>将广播与其他操作结合</h4><p>例：在矩阵 <code>m</code> 中找到与向量 <code>v</code> 距离最近的列向量</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Eigen/Dense&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Eigen;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  	<span class="function">Eigen::MatrixXf <span class="title">m</span><span class="params">(<span class="number">2</span>,<span class="number">4</span>)</span></span>;</span><br><span class="line">  	<span class="function">Eigen::VectorXf <span class="title">v</span><span class="params">(<span class="number">2</span>)</span></span>;</span><br><span class="line">  </span><br><span class="line"> 	 m &lt;&lt; <span class="number">1</span>, <span class="number">23</span>, <span class="number">6</span>, <span class="number">9</span>,</span><br><span class="line">          <span class="number">3</span>, <span class="number">11</span>, <span class="number">7</span>, <span class="number">2</span>;</span><br><span class="line">       </span><br><span class="line">  	v &lt;&lt; <span class="number">2</span>,</span><br><span class="line">         <span class="number">3</span>;</span><br><span class="line"> </span><br><span class="line">  	MatrixXf::Index index;</span><br><span class="line">  	<span class="comment">// find nearest neighbour</span></span><br><span class="line">  	(m.<span class="built_in">colwise</span>() - v).<span class="built_in">colwise</span>().<span class="built_in">squaredNorm</span>().<span class="built_in">minCoeff</span>(&amp;index);</span><br><span class="line"> </span><br><span class="line">  	cout &lt;&lt; <span class="string">&quot;Nearest neighbour is column &quot;</span> &lt;&lt; index &lt;&lt; <span class="string">&quot;:&quot;</span> &lt;&lt; endl;</span><br><span class="line">  	cout &lt;&lt; m.<span class="built_in">col</span>(index) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Nearest neighbour is column 0:</span><br><span class="line">1</span><br><span class="line">3</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://weihongpan.github.io/Eigen/%E9%AB%98%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.jpg">
      <meta itemprop="name" content="潘薇鸿">
      <meta itemprop="description" content="跬步千里">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="潘薇鸿">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/Eigen/%E9%AB%98%E7%BA%A7%E5%88%9D%E5%A7%8B%E5%8C%96/" class="post-title-link" itemprop="url">高级初始化</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2021-04-22 11:03:50" itemprop="dateCreated datePublished" datetime="2021-04-22T11:03:50+08:00">2021-04-22</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-04-23 15:37:24" itemprop="dateModified" datetime="2021-04-23T15:37:24+08:00">2021-04-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/Eigen/" itemprop="url" rel="index"><span itemprop="name">Eigen</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>本章介绍矩阵初始化的一些高级方法，包括逗号初始化和一些特殊矩阵（单位矩阵、零矩阵）初始化</p>
<h3 id="逗号初始化"><a href="#逗号初始化" class="headerlink" title="逗号初始化"></a>逗号初始化</h3><ul>
<li><p>系数初始化顺序：从左上角开始，按从左到右，从上到下的顺序排列</p>
</li>
<li><p>必须预先规定好矩阵/向量/数组的大小，否则会报错</p>
</li>
<li><p>初始化列表的元素除了数值外，也可以是向量或矩阵，常用来连接几个向量或矩阵，同样必须预先规定好大小：</p>
</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">RowVectorXd <span class="title">vec1</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">	vec1 &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;vec1 = &quot;</span> &lt;&lt; vec1 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">RowVectorXd <span class="title">vec2</span><span class="params">(<span class="number">4</span>)</span></span>;</span><br><span class="line">	vec2 &lt;&lt; <span class="number">1</span>, <span class="number">4</span>, <span class="number">9</span>, <span class="number">16</span>;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;vec2 = &quot;</span> &lt;&lt; vec2 &lt;&lt; endl;</span><br><span class="line"> </span><br><span class="line">	<span class="function">RowVectorXd <span class="title">joined</span><span class="params">(<span class="number">7</span>)</span></span>;</span><br><span class="line">	joined &lt;&lt; vec1, vec2;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;joined = &quot;</span> &lt;&lt; joined &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vec1 = 1 2 3</span><br><span class="line">vec2 =  1  4  9 16</span><br><span class="line">joined =  1  2  3  1  4  9 16</span><br></pre></td></tr></table></figure>
<ul>
<li>可以用同样的方法按块结构初始化矩阵：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">MatrixXf <span class="title">matA</span><span class="params">(<span class="number">2</span>, <span class="number">2</span>)</span></span>;</span><br><span class="line">	matA &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>;</span><br><span class="line">	<span class="function">MatrixXf <span class="title">matB</span><span class="params">(<span class="number">4</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	matB &lt;&lt; matA, matA/<span class="number">10</span>, matA/<span class="number">10</span>, matA;</span><br><span class="line">	cout &lt;&lt; matB &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  <span class="number">1</span>   <span class="number">2</span> <span class="number">0.1</span> <span class="number">0.2</span></span><br><span class="line">  <span class="number">3</span>   <span class="number">4</span> <span class="number">0.3</span> <span class="number">0.4</span></span><br><span class="line"><span class="number">0.1</span> <span class="number">0.2</span>   <span class="number">1</span>   <span class="number">2</span></span><br><span class="line"><span class="number">0.3</span> <span class="number">0.4</span>   <span class="number">3</span>   <span class="number">4</span></span><br></pre></td></tr></table></figure>
<ul>
<li>逗号初始化也可以用来为块表达式赋值：</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	Matrix3f m;</span><br><span class="line">	m.<span class="built_in">row</span>(<span class="number">0</span>) &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">	m.<span class="built_in">block</span>(<span class="number">1</span>,<span class="number">0</span>,<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">4</span>, <span class="number">5</span>, <span class="number">7</span>, <span class="number">8</span>;</span><br><span class="line">	m.<span class="built_in">col</span>(<span class="number">2</span>).<span class="built_in">tail</span>(<span class="number">2</span>) &lt;&lt; <span class="number">6</span>, <span class="number">9</span>;                   </span><br><span class="line">	cout &lt;&lt; m;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3</span><br><span class="line">4 5 6</span><br><span class="line">7 8 9</span><br></pre></td></tr></table></figure>
<h3 id="特殊矩阵与数组"><a href="#特殊矩阵与数组" class="headerlink" title="特殊矩阵与数组"></a>特殊矩阵与数组</h3><p>参考手册 <a target="_blank" rel="noopener" href="http://eigen.tuxfamily.org/dox/group__QuickRefPage.html#title3">Quick Reference Guide - Predefined Matrices</a> </p>
<h4 id="Zero"><a href="#Zero" class="headerlink" title="Zero()"></a>Zero()</h4><p>初始化所有系数为0，共有三种形式：</p>
<ul>
<li><code>Zero()</code> : 不接收任何变量，仅用于固定大小的对象；</li>
<li><code>Zero(size)</code> : 接收一个变量，仅用于一维动态大小的对象；</li>
<li><code>Zero(rows,cols)</code> : 接收两个变量，仅用于二维动态大小的对象。</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A fixed-size array:\n&quot;</span>;</span><br><span class="line">	Array33f a1 = Array33f::<span class="built_in">Zero</span>();</span><br><span class="line">	cout &lt;&lt; a1 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A one-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">	ArrayXf a2 = ArrayXf::<span class="built_in">Zero</span>(<span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; a2 &lt;&lt; <span class="string">&quot;\n\n&quot;</span>;</span><br><span class="line"></span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;A two-dimensional dynamic-size array:\n&quot;</span>;</span><br><span class="line">	ArrayXXf a3 = ArrayXXf::<span class="built_in">Zero</span>(<span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line">	cout &lt;&lt; a3 &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">A fixed-size array:</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line">0 0 0</span><br><span class="line"></span><br><span class="line">A one-dimensional dynamic-size array:</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line">0</span><br><span class="line"></span><br><span class="line">A two-dimensional dynamic-size array:</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br><span class="line">0 0 0 0</span><br></pre></td></tr></table></figure>
<h4 id="Ones"><a href="#Ones" class="headerlink" title="Ones()"></a>Ones()</h4><p>初始化所有系数为1，三种形式与 <code>Zero()</code> 相同</p>
<h4 id="Random"><a href="#Random" class="headerlink" title="Random()"></a>Random()</h4><p>初始化所有系数为随机数，三种形式与 <code>Zero()</code> 相同</p>
<h4 id="Constant-value"><a href="#Constant-value" class="headerlink" title="Constant(value)"></a>Constant(value)</h4><p>初始化所有系数为value，同样三种形式：</p>
<ul>
<li><code>Constant(value)</code></li>
<li><code>Constant(size,value)</code></li>
<li><code>Constant(rows,cols,value)</code> </li>
</ul>
<h4 id="Identity"><a href="#Identity" class="headerlink" title="Identity()"></a>Identity()</h4><p>返回单位矩阵，仅用于 Matrix 类，包括 <code>Identity()</code> 和 <code>Identity(rows,cols)</code> </p>
<h4 id="LinSpaced-size-low-high"><a href="#LinSpaced-size-low-high" class="headerlink" title="LinSpaced(size, low, high)"></a>LinSpaced(size, low, high)</h4><p>仅用于向量或一维数组，返回一个指定大小的向量，其系数在参数 <code>low</code> 和 <code>high</code> 之间等距分布</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">ArrayXXf <span class="title">table</span><span class="params">(<span class="number">10</span>, <span class="number">4</span>)</span></span>;</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">0</span>) = ArrayXf::<span class="built_in">LinSpaced</span>(<span class="number">10</span>, <span class="number">0</span>, <span class="number">90</span>);</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">1</span>) = M_PI / <span class="number">180</span> * table.<span class="built_in">col</span>(<span class="number">0</span>);</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">2</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">sin</span>();</span><br><span class="line">	table.<span class="built_in">col</span>(<span class="number">3</span>) = table.<span class="built_in">col</span>(<span class="number">1</span>).<span class="built_in">cos</span>();</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;  Degrees   Radians      Sine    Cosine\n&quot;</span>;</span><br><span class="line">	cout &lt;&lt; table &lt;&lt; std::endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Degrees   Radians      Sine    Cosine</span><br><span class="line">      0         0         0         1</span><br><span class="line">     10     0.175     0.174     0.985</span><br><span class="line">     20     0.349     0.342      0.94</span><br><span class="line">     30     0.524       0.5     0.866</span><br><span class="line">     40     0.698     0.643     0.766</span><br><span class="line">     50     0.873     0.766     0.643</span><br><span class="line">     60      1.05     0.866       0.5</span><br><span class="line">     70      1.22      0.94     0.342</span><br><span class="line">     80       1.4     0.985     0.174</span><br><span class="line">     90      1.57         1 -4.37e-08</span><br></pre></td></tr></table></figure>
<p>从这些例子可以看出，上述方法都会返回一个矩阵或数组再赋值给变量（或表达式），方便起见，Eigen还定义了一些函数来方便地执行这些操作，例如 <code>setZero()</code>  <code>MatrixBase::setIdentity()</code>  <code>DenseBase::setLinSpaced()</code> 等。下面这个例程展示了如何使用静态方法、逗号初始化和 <code>setXxx()</code> 函数来初始化矩阵：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> size = <span class="number">6</span>;</span><br><span class="line"><span class="function">MatrixXd <span class="title">mat1</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat1.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)     = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)    = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>)  = MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">mat1.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>) = MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat1 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat2</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat2.<span class="built_in">topLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">mat2.<span class="built_in">topRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomLeftCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setIdentity</span>();</span><br><span class="line">mat2.<span class="built_in">bottomRightCorner</span>(size/<span class="number">2</span>, size/<span class="number">2</span>).<span class="built_in">setZero</span>();</span><br><span class="line">std::cout &lt;&lt; mat2 &lt;&lt; std::endl &lt;&lt; std::endl;</span><br><span class="line"> </span><br><span class="line"><span class="function">MatrixXd <span class="title">mat3</span><span class="params">(size, size)</span></span>;</span><br><span class="line">mat3 &lt;&lt; MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>),</span><br><span class="line">        MatrixXd::<span class="built_in">Identity</span>(size/<span class="number">2</span>, size/<span class="number">2</span>), MatrixXd::<span class="built_in">Zero</span>(size/<span class="number">2</span>, size/<span class="number">2</span>);</span><br><span class="line">std::cout &lt;&lt; mat3 &lt;&lt; std::endl;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br><span class="line"></span><br><span class="line">0 0 0 1 0 0</span><br><span class="line">0 0 0 0 1 0</span><br><span class="line">0 0 0 0 0 1</span><br><span class="line">1 0 0 0 0 0</span><br><span class="line">0 1 0 0 0 0</span><br><span class="line">0 0 1 0 0 0</span><br></pre></td></tr></table></figure>
<p>除此之外，Eigen还定义了一些用于生成基向量的方法：</p>
<ul>
<li><code>Vector3f::UnitX()</code> : (1, 0, 0)</li>
<li><code>Vector3f::UnitY()</code> : (0, 1, 0)</li>
<li><code>Vector3f::UnitZ()</code> : (0, 0, 1)</li>
<li><code>VectorXf::Unit(size,i)</code> : <ul>
<li>例如 ：<code>VectorXf::Unit(4,1)</code> == <code>Vector4f(0,1,0,0)</code> == <code>Vector4f::UnitY()</code> </li>
</ul>
</li>
</ul>
<h3 id="用作临时对象"><a href="#用作临时对象" class="headerlink" title="用作临时对象"></a>用作临时对象</h3><p>无论是逗号初始化程序还是上面介绍的几种类内静态方法，都可以用作表达式中的临时对象。</p>
<p>逗号初始化程序用作临时对象时，需要调用 <code>finished()</code> 方法获取实际的矩阵对象。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	MatrixXd m = MatrixXd::<span class="built_in">Random</span>(<span class="number">3</span>,<span class="number">3</span>);</span><br><span class="line">    m = (m + MatrixXd::<span class="built_in">Constant</span>(<span class="number">3</span>,<span class="number">3</span>,<span class="number">1.2</span>)) * <span class="number">50</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m =&quot;</span> &lt;&lt; endl &lt;&lt; m &lt;&lt; endl;</span><br><span class="line">    <span class="function">VectorXd <span class="title">v</span><span class="params">(<span class="number">3</span>)</span></span>;</span><br><span class="line">    v &lt;&lt; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;m * v =&quot;</span> &lt;&lt; endl &lt;&lt; m * v &lt;&lt; endl;</span><br><span class="line">    MatrixXf mat = MatrixXf::<span class="built_in">Random</span>(<span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mat =\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">	mat = (<span class="built_in">MatrixXf</span>(<span class="number">2</span>,<span class="number">2</span>) &lt;&lt; <span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">0</span>).<span class="built_in">finished</span>() * mat;</span><br><span class="line">	cout &lt;&lt; <span class="string">&quot;mat =\n&quot;</span> &lt;&lt; mat &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>输出：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">m =</span><br><span class="line">  10 55.9 14.7</span><br><span class="line">23.2 63.3 77.9</span><br><span class="line">85.6 31.9 77.9</span><br><span class="line">m * v =</span><br><span class="line">166</span><br><span class="line">383</span><br><span class="line">383</span><br><span class="line">mat =</span><br><span class="line">     -1   0.511  0.0655</span><br><span class="line"> -0.737 -0.0827  -0.562</span><br><span class="line">mat =</span><br><span class="line"> -0.737 -0.0827  -0.562</span><br><span class="line">     -1   0.511  0.0655</span><br></pre></td></tr></table></figure>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/5/">5</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
    <img class="site-author-image" itemprop="image" alt="潘薇鸿"
      src="/images/avatar.jpg">
  <p class="site-author-name" itemprop="name">潘薇鸿</p>
  <div class="site-description" itemprop="description">跬步千里</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">47</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">8</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author motion-element">
      <span class="links-of-author-item">
        <a href="https://github.com/WeihongPan" title="GitHub → https://github.com/WeihongPan" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">潘薇鸿</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Gemini</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/pisces.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  
      

<script>
  if (typeof MathJax === 'undefined') {
    window.MathJax = {
      loader: {
        source: {
          '[tex]/amsCd': '[tex]/amscd',
          '[tex]/AMScd': '[tex]/amscd'
        }
      },
      tex: {
        inlineMath: {'[+]': [['$', '$']]},
        tags: 'ams'
      },
      options: {
        renderActions: {
          findScript: [10, doc => {
            document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
              const display = !!node.type.match(/; *mode=display/);
              const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
              const text = document.createTextNode('');
              node.parentNode.replaceChild(text, node);
              math.start = {node: text, delim: '', n: 0};
              math.end = {node: text, delim: '', n: 0};
              doc.math.push(math);
            });
          }, '', false],
          insertedScript: [200, () => {
            document.querySelectorAll('mjx-container').forEach(node => {
              let target = node.parentNode;
              if (target.nodeName.toLowerCase() === 'li') {
                target.parentNode.classList.add('has-jax');
              }
            });
          }, '', false]
        }
      }
    };
    (function () {
      var script = document.createElement('script');
      script.src = '//cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js';
      script.defer = true;
      document.head.appendChild(script);
    })();
  } else {
    MathJax.startup.document.state(0);
    MathJax.texReset();
    MathJax.typeset();
  }
</script>

    

  

</body>
</html>
